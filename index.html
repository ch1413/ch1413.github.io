<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…¨å›½å…¬å•æ™ºèƒ½å¯¼èˆªç³»ç»Ÿ</title>
    <!-- AMap JS API will be loaded dynamically using CONFIG.AMAP_JS_KEY and CONFIG.AMAP_JS_SECURITY -->
    <!-- AMap JS and its security will be set dynamically by loadAMapScript at runtime. -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Microsoft YaHei", sans-serif;
        }

        body,
        html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        /* ç³»ç»Ÿå¤´éƒ¨ */
        .system-header {
            height: 60px;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 30px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            position: relative;
            z-index: 1000;
        }

        .system-title {
            font-size: 20px;
            font-weight: bold;
            color: #2c3e50;
            display: flex;
            align-items: center;

            /* Center the title horizontally within the header */
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            justify-content: center;

            /* Prevent overlap with controls: truncate long titles */
            max-width: calc(100% - 240px);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 0 12px;
            z-index: 1010;
        }

        /* Make header elements responsive on small screens */
        @media (max-width: 480px) {
            .system-title { font-size: 16px; max-width: calc(100% - 140px); }
            .system-version { display: none; }
        }

        .system-title i {
            margin-right: 10px;
            font-size: 24px;
            color: #3498db;
        }

        .system-version {
            font-size: 14px;
            color: #7f8c8d;
            background: #f8f9fa;
            padding: 5px 15px;
            border-radius: 20px;
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1011;
        }

        /* åœ°å›¾å®¹å™¨ - ä¿®å¤Canvasæ€§èƒ½è­¦å‘Š */
        #mapContainer {
            width: 100%;
            height: calc(100vh - 60px);
            position: relative;
        }

        /* å·¦ä¾§æ§åˆ¶é¢æ¿ */
        .left-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 320px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
            z-index: 100;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(5px);
        }

        /* å³ä¾§å¯¼èˆªé¢æ¿ï¼ˆå¯æ»‘åŠ¨ï¼‰ */
        .right-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            -webkit-overflow-scrolling: touch; /* iOS å¹³æ»‘æ»šåŠ¨ */
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
            z-index: 100;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(5px);
        }

        /* ä½¿é¢æ¿å†…çš„æ ‡é¢˜æˆ–é‡è¦ä¿¡æ¯å¯å›ºå®šåœ¨é¡¶éƒ¨ï¼Œä¾¿äºè§‚å¯Ÿ */
        .right-panel .sticky {
            position: -webkit-sticky;
            position: sticky;
            top: 0;
            background: rgba(255,255,255,0.95);
            padding-bottom: 8px;
            z-index: 10;
            border-bottom: 1px solid #eee;
        }

        .panel-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }

        .panel-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .section-title {
            font-size: 16px;
            color: #2c3e50;
            margin-bottom: 15px;
            font-weight: 600;
            display: flex;
            align-items: center;
        }

        .section-title i {
            margin-right: 8px;
            color: #3498db;
        }

        /* è¾“å…¥æ¡†å’Œé€‰æ‹©å™¨æ ·å¼ */
        .input-group {
            margin-bottom: 15px;
        }

        .input-label {
            display: block;
            font-size: 13px;
            color: #3498db;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .input-field,
        .select-field {
            width: 100%;
            padding: 10px 15px;
            border: 2px solid #e0e6ed;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s;
            background: #f8fafc;
        }

        .input-field:focus,
        .select-field:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
        }

        /* æŒ‰é’®æ ·å¼ */
        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
        }

        /* çƒ­åŠ›å›¾æ§åˆ¶æŒ‰é’®ç»„ - æ–°å¢ */
        .heatmap-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }

        .btn {
            padding: 10px 15px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #2980b9, #2573a7);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #8e44ad, #7d3c98);
            transform: translateY(-1px);
        }

        .btn-success {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            color: white;
        }

        .btn-success:hover {
            background: linear-gradient(135deg, #27ae60, #219653);
            transform: translateY(-1px);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f39c12, #e67e22);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }

        /* çƒ­åŠ›å›¾æ§åˆ¶æŒ‰é’®æ ·å¼ - æ–°å¢ */
        .btn-heatmap {
            background: linear-gradient(135deg, #e67e22, #d35400);
            color: white;
            font-size: 13px;
            padding: 8px 5px;
        }

        .btn-heatmap:hover {
            background: linear-gradient(135deg, #d35400, #c0392b);
            transform: translateY(-1px);
        }

        /* çŠ¶æ€æ˜¾ç¤º */
        .status-panel {
            margin-top: 15px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #3498db;
            font-size: 13px;
            color: #2c3e50;
        }

        /* å¯¼èˆªä¿¡æ¯é¢æ¿ */
        .navigation-info {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }

        .nav-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
        }

        .nav-value {
            font-weight: 600;
            color: #2c3e50;
        }

        .nav-distance {
            color: #e74c3c;
            font-size: 18px;
            font-weight: bold;
        }

        .nav-time {
            color: #3498db;
            font-size: 16px;
            font-weight: bold;
        }

        /* çƒ­åŠ›å›¾å›¾ä¾‹ï¼ˆç§»å…¥ä¾§è¾¹æ ä»¥é˜²é®æŒ¡ï¼‰ */
        .heatmap-legend {
            position: relative;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            padding: 8px 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.06);
            z-index: 10;
            display: none;
        }

        .legend-title {
            font-size: 12px;
            color: #2c3e50;
            margin-bottom: 6px;
            font-weight: 600;
            text-align: center;
        }

        .legend-gradient {
            width: 100%;
            height: 12px;
            background: linear-gradient(to right, rgba(128, 0, 128, 0.7), rgba(255, 0, 0, 0.8), rgba(255, 165, 0, 0.9), rgba(255, 255, 0, 1), rgba(255, 255, 255, 1));
            border-radius: 4px;
            margin-bottom: 5px;
        }

        .legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #7f8c8d;
        }

        .nav-character {
            width: 40px;
            height: 40px;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="30" r="20" fill="%23ff6b6b"/><path d="M30,70 Q50,90 70,70 L50,50 Z" fill="%234ecdc4"/><circle cx="40" cy="25" r="5" fill="white"/><circle cx="60" cy="25" r="5" fill="white"/><path d="M45,35 Q50,40 55,35" stroke="white" stroke-width="3" fill="none"/></svg>') no-repeat center;
            background-size: contain;
            border-radius: 50%;
            transition: transform 0.1s linear;
            z-index: 1000;
            pointer-events: none;
        }

        .nav-progress {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 600px;
            height: 8px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            z-index: 1000;
            overflow: hidden;
        }

        .nav-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            width: 0%;
            transition: width 0.3s linear;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 1200px) {
            .right-panel {
                display: none;
            }

            .left-panel {
                width: 95%;
                left: 2.5%;
            }

            .heatmap-legend {
                width: 90%;
                left: 5%;
            }
        }
    </style>
</head>

<body>
    <!-- ç³»ç»Ÿå¤´éƒ¨ -->
    <div class="system-header">
        <div class="system-title">
            <<i>ğŸš½</< /i>
                å…¨å›½å…¬å•æ™ºèƒ½å¯¼èˆªç³»ç»Ÿ
        </div>
        <div class="system-version">
            v2.2 - ä¿®å¤çƒ­åŠ›å›¾&å¯¼èˆªåŠ¨ç”»
        </div>
    </div>

    <!-- åœ°å›¾å®¹å™¨ -->
    <div id="mapContainer"></div>

    <!-- å¯¼èˆªè¿›åº¦æ¡ -->
    <div class="nav-progress" id="navProgress" style="display: none;">
        <div class="nav-progress-bar" id="navProgressBar"></div>
    </div>



    <!-- å·¦ä¾§æ§åˆ¶é¢æ¿ -->
    <div class="left-panel">
        <!-- åœ°å›¾æ¨¡å¼åˆ‡æ¢ -->
        <div class="panel-section">
            <div class="section-title">
                <<i>ğŸ—ºï¸</< /i>
                    åœ°å›¾æ¨¡å¼
            </div>
            <div class="btn-group">
                <button class="btn btn-primary" id="btnNormalMap">
                    <<i>ğŸŒ</< /i>
                        æ ‡å‡†åœ°å›¾
                </button>
                <button class="btn btn-secondary" id="btnSatellite">
                    <<i>ğŸ›°ï¸</< /i>
                        å«æ˜Ÿå½±åƒ
                </button>
                <button class="btn btn-warning" id="btnDarkHeatmap">
                    <i>ğŸ”¥</i>
                        æ·±è‰²çƒ­åŠ›å›¾
                </button>
                <label style="display:inline-flex; align-items:center; margin-left:8px; font-size:12px;">
                    <input type="checkbox" id="chkQgisWms" style="margin-right:6px;" /> æ˜¾ç¤º QGIS WMS å›¾å±‚
                </label>
            </div>

            <!-- çƒ­åŠ›å›¾æ§åˆ¶æŒ‰é’®ç»„ - æ–°å¢ -->
            <div class="heatmap-controls">
                <button class="btn btn-heatmap" id="btnHeatmapSmall">
                    <<i>ğŸ”</i>
                        å°åŠå¾„
                </button>
                <button class="btn btn-heatmap" id="btnHeatmapMedium">
                    <<i>ğŸ”</i>
                        ä¸­åŠå¾„
                </button>
                <button class="btn btn-heatmap" id="btnHeatmapLarge">
                    <<i>ğŸ”</i>
                        å¤§åŠå¾„
                </button>
            </div>
            <!-- çƒ­åŠ›å›¾å€¼æ˜¾ç¤ºï¼ˆæ˜¾ç¤ºåœ¨å°åŠå¾„ä¸‹é¢ï¼‰ -->
            <div id="heatmapValue" style="margin-top:6px; font-size:13px; color:#2c3e50; display:none;">å·²æ˜¾ç¤ºçƒ­åŠ›å›¾ - åŠå¾„: 0px</div>

            <!-- çƒ­åŠ›å›¾å›¾ä¾‹ï¼ˆç§»è‡³ä¾§è¾¹æ ä»¥é˜²é®æŒ¡åœ°å›¾ï¼‰ -->
            <div class="heatmap-legend" id="heatmapLegend" style="display:none; margin-top:8px;">
                <div class="legend-title">å…¬å•çƒ­åº¦åˆ†å¸ƒ</div>
                <div class="legend-gradient" style="width:100%; height:12px; border-radius:4px; margin:6px 0;"></div>
                <div class="legend-labels" style="display:flex; justify-content:space-between; font-size:12px; color:#666;">
                    <span>ä½çƒ­åº¦</span>
                    <span>ä¸­çƒ­åº¦</span>
                    <span>é«˜çƒ­åº¦</span>
                </div>
            </div>
        </div>

        <!-- ä½ç½®æœç´¢ -->
        <div class="panel-section">
            <div class="section-title">
                <<i>ğŸ“</< /i>
                    ä½ç½®æœç´¢
            </div>
            <div class="input-group">
                <label class="input-label">æœç´¢åŸå¸‚æˆ–åŒºåŸŸ</label>
                <input type="text" class="input-field" id="searchCity" placeholder="è¾“å…¥åŸå¸‚åç§°ï¼Œå¦‚ï¼šåŒ—äº¬ã€ä¸Šæµ·" value="åŒ—äº¬">
            </div>
            <button class="btn btn-primary" id="btnSearchCity" style="width: 100%; margin-bottom: 10px;">
                <<i>ğŸ”</< /i>
                    æœç´¢åŒºåŸŸå…¬å•
            </button>
            <button class="btn btn-secondary" id="btnGetLocation" style="width: 100%;">
                <<i>ğŸ“</< /i>
                    è·å–å½“å‰ä½ç½®
            </button>
        </div>

        <!-- å…¬å•æ˜¾ç¤ºæ§åˆ¶ -->
        <div class="panel-section">
            <div class="section-title">
                <<i>ğŸš½</< /i>
                    å…¬å•æ˜¾ç¤º
            </div>
            <div class="btn-group">
                <button class="btn btn-primary" id="btnShowAll">
                    <i>ğŸ </i>
                        æ˜¾ç¤ºå…¨éƒ¨
                </button>
                <button class="btn btn-outline-info" id="btnTestKeys" title="æµ‹è¯• JS Key ä¸ REST Key">
                    <i>ğŸ§ª</i>
                        æµ‹è¯•Key
                </button>

                <!-- å¯é€‰ï¼šä½¿ç”¨ REST Geocoder è¡¥å…¨ï¼ˆå‰ç«¯ä¼šä½¿ç”¨ REST Keyï¼‰ -->
                <label style="display:inline-flex; align-items:center; margin-left:8px; font-size:12px;">
                    <input type="checkbox" id="chkAllowRestGeocode" style="margin-right:6px;" />
                    å…è®¸ä½¿ç”¨ REST Geocoder è¡¥å…¨ï¼ˆä¼šä½¿ç”¨ REST Keyï¼‰
                </label>
                <button class="btn btn-outline-secondary" id="btnRunRestGeocode" title="æ‰‹åŠ¨ä½¿ç”¨ REST è¡¥å…¨" style="margin-left:8px;">
                    <i>ğŸ”</i>
                        ä½¿ç”¨ REST è¡¥å…¨ï¼ˆæ‰‹åŠ¨ï¼‰
                </button>

                <button class="btn btn-danger" id="btnClearAll">
                    <i>ğŸ—‘ï¸</i>
                        æ¸…ç©ºæ˜¾ç¤º
                </button>
            </div>
            <!-- è°ƒè¯•é¢æ¿ï¼šæ˜¾ç¤ºè·³è¿‡ä¸è¡¥å…¨ç»Ÿè®¡ -->
            <div id="debugPanel" style="margin-top:8px; padding:8px; border-left:3px solid #f1c40f; background:#fffef7; display:none; font-size:12px;">
                <div id="debugSummary">è°ƒè¯•ä¿¡æ¯ï¼šæ— </div>
                <div id="debugDetails" style="margin-top:6px; max-height:120px; overflow:auto; white-space:pre-wrap;"></div>

                <!-- WMS æ¢æµ‹ç»“æœåŒº -->
                <div id="wmsProbePanel" style="margin-top:8px; padding-top:8px; border-top:1px dashed #ddd; display:block;">
                    <div id="wmsProbeSummary" style="font-weight:600;">WMS æ¢æµ‹ï¼šæœªè¿è¡Œ</div>
                    <div id="wmsProbeDetails" style="margin-top:6px; max-height:140px; overflow:auto; white-space:pre-wrap; font-size:12px; color:#333;"></div>
                    <div style="margin-top:6px; display:flex; gap:6px; align-items:center;">
                        <label style="font-size:12px; display:flex; align-items:center; gap:6px;"><input type="checkbox" id="chkUseWmsProxy"> ä½¿ç”¨ä»£ç†</label>
                        <button class="btn" id="btnCopyWmsLog" style="font-size:12px; padding:4px 8px;">å¤åˆ¶æ¢æµ‹æ—¥å¿—</button>
                    </div>
                    <input type="text" id="txtWmsProxyUrl" placeholder="ä»£ç†å‰ç¼€ï¼ˆä¾‹å¦‚ https://your-proxy.example/tiles?url=ï¼‰" style="width:100%;margin-top:6px;font-size:12px;" />
                </div>
            </div> 
        </div>

        <!-- ç³»ç»ŸçŠ¶æ€ -->
        <div class="status-panel" id="systemStatus">
            ç³»ç»Ÿåˆå§‹åŒ–ä¸­...
        </div>
    </div>

    <!-- å³ä¾§ï¼šå¯¼èˆªæ§åˆ¶é¢æ¿ -->
    <div class="right-panel">
        <div class="sticky" id="heatmapInfo" style="font-size:12px; color:#333; margin-bottom:8px; display:block;">çƒ­åŠ›å›¾ï¼šæœªå¯ç”¨</div>
        <!-- å¯¼èˆªè®¾ç½® -->
        <div class="panel-section">
            <div class="section-title">
                <<i>ğŸ§­</< /i>
                    å¯¼èˆªè®¾ç½®
            </div>
            <div class="input-group">
                <label class="input-label">å½“å‰ä½ç½®</label>
                <input type="text" class="input-field" id="currentPosition" placeholder="ç‚¹å‡»åœ°å›¾æˆ–è‡ªåŠ¨è·å–" readonly>
            </div>
            <div class="input-group">
                <label class="input-label">ç›®æ ‡å…¬å•</label>
                <select class="select-field" id="selectToilet">
                    <option value="">è¯·é€‰æ‹©ç›®æ ‡å…¬å•</option>
                </select>
            </div>
            <div class="input-group">
                <label class="input-label">äº¤é€šå·¥å…·</label>
                <select class="select-field" id="transportMode">
                    <option value="walking">æ­¥è¡Œ</option>
                    <option value="driving" selected>é©¾è½¦</option>
                    <option value="bicycling">éª‘è¡Œ</option>
                    <option value="transit">å…¬äº¤</option>
                </select>
            </div>
            <button class="btn btn-success" id="btnStartNavigation" style="width: 100%;">
                <<i>ğŸš€</< /i>
                    å¼€å§‹å¯¼èˆª
            </button>
            <button class="btn btn-warning" id="btnPauseNavigation"
                style="width: 100%; margin-top: 10px; display: none;">
                <<i>â¸ï¸</< /i>
                    æš‚åœå¯¼èˆª
            </button>
        </div>

        <!-- å¯¼èˆªä¿¡æ¯ -->
        <div class="navigation-info" id="navInfo" style="display: none;">
            <div class="nav-item">
                <span>ç›®çš„åœ°ï¼š</span>
                <span class="nav-value" id="navDestination">-</span>
            </div>
            <div class="nav-item">
                <span>è·ç¦»ï¼š</span>
                <span class="nav-distance" id="navDistance">-</span>
            </div>
            <div class="nav-item">
                <span>é¢„è®¡æ—¶é—´ï¼š</span>
                <span class="nav-time" id="navTime">-</span>
            </div>
            <div class="nav-item">
                <span>äº¤é€šå·¥å…·ï¼š</span>
                <span class="nav-value" id="navTransport">-</span>
            </div>
            <button class="btn btn-danger" id="btnStopNav" style="width: 100%; margin-top: 10px;">
                <<i>â¹ï¸</< /i>
                    ç»“æŸå¯¼èˆª
            </button>
        </div>

        <!-- å…¬å•ç»Ÿè®¡ -->
        <div class="panel-section">
            <div class="section-title">
                <<i>ğŸ“Š</< /i>
                    å…¬å•ç»Ÿè®¡
            </div>
            <div class="status-panel">
                <div>å…¨å›½å…¬å•æ€»æ•°: <strong id="totalToilets">0</strong></div>
                <div>å½“å‰æ˜¾ç¤º: <strong id="displayedToilets">0</strong></div>
                <div>æ™®é€šå…¬å•: <span style="color:#3498db;" id="generalCount">0</span></div>
                <div>æ— éšœç¢: <span style="color:#e74c3c;" id="accessibleCount">0</span></div>
                <div>æ¯å©´å®¤: <span style="color:#9b59b6;" id="motherCount">0</span></div>
            </div>
        </div>
    </div>

    <script>
        // ============ ç³»ç»Ÿé…ç½® ============
        const CONFIG = {
            AMAP_JS_KEY: '3da096629cc77da916196115d45f9d63', // é«˜å¾·Webç«¯JS API Keyï¼ˆä»…ç”¨äº webapi ï¼‰
            AMAP_JS_SECURITY: '99e3954b4b466ebbbe24118338ef6c91', // JS API å®‰å…¨å¯†é’¥ï¼ˆä»…JS APIä½¿ç”¨ï¼‰
            AMAP_REST_KEY: '9666a97081858f91bc01602ef209e226', // é«˜å¾·WebæœåŠ¡ REST API Keyï¼ˆä»…ç”¨äº restapi ï¼‰

            DEFAULT_CENTER: [116.397428, 39.90923], // åŒ—äº¬ä¸­å¿ƒ
            DEFAULT_ZOOM: 5, // å…¨å›½è§†å›¾
            MAX_ZOOM: 16, // å«æ˜Ÿå›¾æœ€å¤§ç¼©æ”¾çº§åˆ«ï¼ˆé¿å…ç©ºç™½ï¼‰
            HEATMAP_OPTIONS: {
                radius: 20,  // çƒ­åŠ›å›¾é»˜è®¤åŠå¾„
                minRadius: 10, // æœ€å°åŠå¾„
                maxRadius: 30, // æœ€å¤§åŠå¾„
                opacity: [0, 0.9],
                gradient: {  // æ·±è‰²çƒ­åŠ›å›¾é…è‰²
                    0.0: 'rgba(0, 0, 0, 0)',
                    0.1: 'rgba(128, 0, 128, 0.7)',
                    0.3: 'rgba(255, 0, 0, 0.8)',
                    0.5: 'rgba(255, 165, 0, 0.9)',
                    0.7: 'rgba(255, 255, 0, 1)',
                    1.0: 'rgba(255, 255, 255, 1)'
                }
            },
            ANIMATION_SPEED: { // ä¸åŒäº¤é€šå·¥å…·çš„åŠ¨ç”»é€Ÿåº¦ï¼ˆåƒç´ /æ¯«ç§’ï¼‰
                walking: 0.5,
                driving: 2,
                bicycling: 1,
                transit: 1.5
            }
        };

        // åŠ¨æ€åŠ è½½ AMap JSï¼ˆä½¿ç”¨ CONFIG.AMAP_JS_KEY + CONFIG.AMAP_JS_SECURITYï¼‰
        function loadAMapScript(callback) {
            if (!CONFIG || !CONFIG.AMAP_JS_KEY) {
                const err = new Error('AMAP_JS_KEY æœªé…ç½®');
                if (callback) callback(err);
                return;
            }
            if (typeof AMap !== 'undefined') {
                if (callback) callback();
                return;
            }

            // é¿å…é‡å¤æ³¨å…¥
            if (document.getElementById('amap-js-script')) {
                const existing = document.getElementById('amap-js-script');
                existing.addEventListener('load', () => { if (callback) callback(); });
                existing.addEventListener('error', () => { if (callback) callback(new Error('AMap script load error')); });
                return;
            }

            // åœ¨æ’å…¥è„šæœ¬å‰è®¾ç½®å®‰å…¨å¯†é’¥ï¼ˆä»… JS API ä½¿ç”¨ï¼‰
            if (CONFIG.AMAP_JS_SECURITY) {
                try { window._AMapSecurityConfig = { securityJsCode: CONFIG.AMAP_JS_SECURITY }; } catch (e) { console.warn('æ— æ³•è®¾ç½® _AMapSecurityConfig:', e); }
            }

            const s = document.createElement('script');
            s.id = 'amap-js-script';
            s.src = `https://webapi.amap.com/maps?v=2.0&key=${CONFIG.AMAP_JS_KEY}&plugin=AMap.ToolBar,AMap.Scale,AMap.HeatMap,AMap.Driving`;
            s.onload = () => { if (callback) callback(); };
            s.onerror = (e) => { if (callback) callback(new Error('AMap script load failed')); };
            document.head.appendChild(s);
        }

        // ============ å…¨å›½å…¬å•æ•°æ®ï¼ˆæ¥æºï¼šé«˜å¾·POIæ£€ç´¢ï¼‰ ============
        // è¿è¡Œæ—¶é€šè¿‡é«˜å¾·POIæ£€ç´¢å¡«å……ï¼Œé¿å…ä½¿ç”¨æœ¬åœ°é™æ€æ•°æ®
        const NATIONAL_TOILET_DATA = [];

        // ============ å…¨å±€å˜é‡ ============
        let map = null;
        let markers = [];
        let currentLocation = null;
        let currentLocationMarker = null;
        let heatmapLayer = null;
        let infoWindow = null;
        let navigationLine = null;
        let isNavigating = false;
        let isPaused = false;
        let currentTransportMode = 'driving';
        let navAnimationFrame = null;
        let navPath = []; // å¯¼èˆªè·¯å¾„åæ ‡æ•°ç»„
        let navCharacterMarker = null; // å¯¼èˆªäººç‰©æ ‡è®°
        let navCurrentIndex = 0; // å½“å‰åŠ¨ç”»ä½ç½®ç´¢å¼•
        let navProgress = 0; // å¯¼èˆªè¿›åº¦ï¼ˆ0-100ï¼‰
        let currentHeatmapRadius = CONFIG.HEATMAP_OPTIONS.radius; // å½“å‰çƒ­åŠ›å›¾åŠå¾„
        let drivingService = null; // AMap.Driving å®ä¾‹å¼•ç”¨ï¼ˆç”¨äºæ¸…ç†è‡ªåŠ¨æ·»åŠ çš„è·¯çº¿è¦†ç›–ï¼‰
        // QGIS Cloud WMS æ”¯æŒ
        let qgisWmsLayer = null;
        let isQgisWmsEnabled = false;
        const QGIS_WMS_BASE = 'https://wms.qgiscloud.com/smilejxl/fx/';
        function getDefaultWmsLayerName() {
            try {
                const url = new URL(QGIS_WMS_BASE);
                const parts = url.pathname.split('/').filter(Boolean);
                return parts.length ? parts[parts.length - 1] : 'fx';
            } catch (e) { return 'fx'; }
        }
        // WMS è‡ªåŠ¨æ£€æµ‹ä¸é…ç½®ä¿¡æ¯
        const wmsConfig = {
            endpoint: null, // base URL that works (candidate)
            version: null, // '1.3.0' or '1.1.1'
            crs: null // 'EPSG:3857' or 'EPSG:4326'
        }; 

        // tile -> bbox (EPSG:3857) helper
        function tileXYZToBBox3857(x, y, z) {
            const tileSize = 256;
            const initialResolution = 2 * Math.PI * 6378137 / tileSize; // meters per pixel at zoom 0
            const originShift = 2 * Math.PI * 6378137 / 2.0;

            function pixelsToMeters(px, py, zoom) {
                const res = initialResolution / Math.pow(2, zoom);
                const mx = px * res - originShift;
                const my = py * res - originShift;
                return [mx, my];
            }

            // tile x,y to pixel coords
            const minPx = x * tileSize;
            const maxPx = (x + 1) * tileSize;
            const minPy = (y + 1) * tileSize;
            const maxPy = y * tileSize;

            const min = pixelsToMeters(minPx, minPy, z);
            const max = pixelsToMeters(maxPx, maxPy, z);
            // return [minx, miny, maxx, maxy]
            return [min[0], min[1], max[0], max[1]];
        }

        // heatmap æ›´æ–°èŠ‚æµ
        let _heatmapUpdateTimer = null;
        // åœ°å›¾äº¤äº’çŠ¶æ€ï¼ˆç”¨äºåœ¨äº¤äº’æ—¶å»¶è¿Ÿçƒ­åŠ›å›¾æ›´æ–°ï¼‰
        let mapIsInteracting = false;
        let _pendingHeatmapData = null;

        // ============ ä¿®å¤ï¼šåœ°å›¾åˆå§‹åŒ– ============
        function initMap() {
            console.log('æ­£åœ¨åˆå§‹åŒ–åœ°å›¾ç³»ç»Ÿ...');

            try {
                // æ£€æŸ¥é«˜å¾·åœ°å›¾APIæ˜¯å¦å¯ç”¨
                if (typeof AMap === 'undefined') {
                    updateStatus('é«˜å¾·åœ°å›¾APIåŠ è½½å¤±è´¥', true);
                    return;
                }

                // åˆå§‹åŒ–åœ°å›¾ - ä¿®å¤Canvasæ€§èƒ½è­¦å‘Š + é€‚é…å«æ˜Ÿå›¾
                map = new AMap.Map('mapContainer', {
                    zoom: CONFIG.DEFAULT_ZOOM,
                    center: CONFIG.DEFAULT_CENTER,
                    viewMode: '2D', // æ”¹ä¸º2Dè§†å›¾ï¼Œæå‡å«æ˜Ÿå›¾å…¼å®¹æ€§
                    mapStyle: 'amap://styles/normal',
                    resizeEnable: true,
                    maxZoom: CONFIG.MAX_ZOOM, // é™åˆ¶æœ€å¤§ç¼©æ”¾çº§åˆ«
                    renderOptions: {
                        willReadFrequently: true  // ä¿®å¤Canvasæ€§èƒ½è­¦å‘Š
                    }
                });

                // åˆå§‹åŠ è½½æ ‡å‡†åœ°å›¾ç“¦ç‰‡ï¼ˆç¡®ä¿é»˜è®¤æ˜¾ç¤ºæ­£å¸¸ï¼‰
                const normalLayer = new AMap.TileLayer({
                    url: 'https://webst0{1,2,3,4}.is.autonavi.com/appmaptile?style=7&x={x}&y={y}&z={z}&key=' + CONFIG.AMAP_JS_KEY,
                    zIndex: 1
                });
                map.add(normalLayer);

                // æ–°å¢ï¼šç›‘å¬åœ°å›¾åŠ è½½é”™è¯¯ï¼ˆå®šä½å«æ˜Ÿå›¾æƒé™é—®é¢˜ï¼‰
                map.on('error', (err) => {
                    console.error('åœ°å›¾åŠ è½½é”™è¯¯:', err);
                    if (err.info.includes('SERVICE_NOT_AVAILABLE')) {
                        updateStatus('å«æ˜Ÿå½±åƒæœåŠ¡æœªå¼€é€šï¼Œå·²è‡ªåŠ¨åˆ‡æ¢è‡³æ ‡å‡†åœ°å›¾', true);
                        switchMapMode('normal');
                    } else if (err.info.includes('INVALID_USER_KEY')) {
                        updateStatus('API Keyæ— æ•ˆï¼Œè¯·æ›´æ¢æ­£ç¡®çš„Webç«¯JS API Key', true);
                    } else if (err.info.includes('OVER_QUERY_LIMIT')) {
                        updateStatus('APIè°ƒç”¨æ¬¡æ•°è¶…é™ï¼Œè¯·ç¨åå†è¯•', true);
                    }
                });

                // ä¿®å¤ï¼šå®‰å…¨çš„æ§ä»¶åŠ è½½
                addMapControlsSafely();

                // åˆ›å»ºä¿¡æ¯çª—å£
                infoWindow = new AMap.InfoWindow({
                    offset: new AMap.Pixel(0, -30),
                    closeWhenClickMap: true
                });

                // ç»‘å®šåœ°å›¾ç‚¹å‡»äº‹ä»¶
                map.on('click', function (e) {
                    setCurrentPosition([e.lnglat.getLng(), e.lnglat.getLat()]);
                });

                // ç›‘å¬åœ°å›¾äº¤äº’ï¼ˆæ‹–åŠ¨ã€ç¼©æ”¾ï¼‰ä»¥ä¾¿å»¶è¿Ÿçƒ­åŠ›å›¾æ›´æ–°ï¼Œå‡å°‘ canvas readback
                map.on('movestart', function () { mapIsInteracting = true; });
                map.on('zoomstart', function () { mapIsInteracting = true; });
                map.on('moveend', function () { mapIsInteracting = false; applyPendingHeatmapIfAny(); try { updateHeatmapInfo(); } catch(e){} });
                map.on('zoomend', function () { mapIsInteracting = false; applyPendingHeatmapIfAny(); try { updateHeatmapInfo(); } catch(e){} });

                // ä¸ä½¿ç”¨æœ¬åœ°é™æ€æ•°æ®ï¼Œç‚¹å‡»â€œæ˜¾ç¤ºå…¨éƒ¨â€ä»é«˜å¾·POIæ£€ç´¢å…¬å•æ•°æ®
                updateStatus('å°±ç»ªï¼šè¯·ç‚¹å‡»â€œæ˜¾ç¤ºå…¨éƒ¨â€ä»é«˜å¾·POIæ£€ç´¢å…¬å•æ•°æ®');
                console.info('åœ°å›¾ renderOptions å·²å¯ç”¨ willReadFrequently=trueï¼Œç”¨äºå‡å°‘ canvas readback æ€§èƒ½è­¦å‘Šï¼ˆè‹¥ä»å‡ºç°æµè§ˆå™¨è­¦å‘Šå¯å¿½ç•¥ï¼‰');

                // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯ï¼ˆåˆå§‹å‡ä¸º0ï¼‰
                updateStatistics();

                updateStatus('å…¨å›½å…¬å•ç³»ç»Ÿå·²å¯åŠ¨ï¼Œæ”¯æŒå«æ˜Ÿå½±åƒåˆ‡æ¢å’Œå¢å¼ºçƒ­åŠ›å›¾');
                console.log('åœ°å›¾ç³»ç»Ÿåˆå§‹åŒ–æˆåŠŸï¼');
                // åˆå§‹åŒ– WMS é¢æ¿äº‹ä»¶ç»‘å®š
                try { setupWmsUiBindings(); } catch (e) { console.debug('setupWmsUiBindings è°ƒç”¨å¤±è´¥', e); }

            } catch (error) {
                console.error('åœ°å›¾åˆå§‹åŒ–å¤±è´¥:', error);
                updateStatus('åœ°å›¾åŠ è½½å¤±è´¥: ' + error.message, true);
            }
        }

        // ============ ä¿®å¤ï¼šå®‰å…¨çš„æ§ä»¶åŠ è½½ ============
        function addMapControlsSafely() {
            // æ·»åŠ æ¯”ä¾‹å°º
            if (window.AMap && AMap.Scale) {
                try {
                    map.addControl(new AMap.Scale({
                        position: 'LB',
                        visible: true
                    }));
                } catch (e) {
                    console.warn('æ¯”ä¾‹å°ºæ§ä»¶åŠ è½½å¤±è´¥:', e.message);
                }
            }

            // ä¿®å¤ToolBaré—®é¢˜
            if (window.AMap && AMap.ToolBar) {
                try {
                    // å…ˆæ£€æŸ¥ç‰ˆæœ¬å…¼å®¹æ€§
                    if (typeof AMap.ToolBar === 'function') {
                        map.addControl(new AMap.ToolBar({
                            position: 'LT',
                            offset: [10, 10]
                        }));
                        console.log('ToolBaræ§ä»¶åŠ è½½æˆåŠŸ');
                    } else {
                        console.warn('ToolBarä¸æ˜¯æ„é€ å‡½æ•°ï¼Œè·³è¿‡');
                    }
                } catch (error) {
                    console.warn('ToolBaråˆå§‹åŒ–å¤±è´¥ï¼Œåˆ›å»ºè‡ªå®šä¹‰å·¥å…·æ ');
                    createCustomToolbar();
                }
            } else {
                console.warn('ToolBaræ§ä»¶ä¸å¯ç”¨ï¼Œåˆ›å»ºè‡ªå®šä¹‰å·¥å…·æ ');
                createCustomToolbar();
            }
        }

        // ============ ä¿®å¤ï¼šè‡ªå®šä¹‰å·¥å…·æ  ============
        function createCustomToolbar() {
            const toolbarDiv = document.createElement('div');
            toolbarDiv.style.cssText = `
                position: absolute;
                top: 20px;
                right: 20px;
                background: white;
                border-radius: 4px;
                box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                padding: 5px;
                z-index: 1000;
                display: flex;
                gap: 5px;
            `;

            toolbarDiv.innerHTML = `
                <button onclick="map.zoomIn()" style="width: 30px; height: 30px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer;">+</button>
                <button onclick="map.zoomOut()" style="width: 30px; height: 30px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer;">-</button>
            `;

            document.getElementById('mapContainer').appendChild(toolbarDiv);
        }

        // ============ æ ¸å¿ƒåŠŸèƒ½å®ç° ============

        // 1. åŠ è½½æ‰€æœ‰å…¬å•
        function loadAllToilets() {
            clearMarkers();

            if (!NATIONAL_TOILET_DATA || NATIONAL_TOILET_DATA.length === 0) {
                updateStatus('å½“å‰æ²¡æœ‰å…¬å•æ•°æ®ã€‚è¯·ç‚¹å‡»â€œæ˜¾ç¤ºå…¨éƒ¨â€ä»é«˜å¾·POIæ£€ç´¢å…¬å•æ•°æ®', true);
                updateStatistics();
                return;
            }

            NATIONAL_TOILET_DATA.forEach(toilet => {
                const marker = createToiletMarker(toilet);
                markers.push(marker);
                map.add(marker);
            });

            // è°ƒæ•´åˆ°åˆé€‚è§†é‡æ˜¾ç¤ºå…¨å›½
            map.setZoomAndCenter(CONFIG.DEFAULT_ZOOM, CONFIG.DEFAULT_CENTER);
            updateStatus(`å·²åŠ è½½å…¨å›½ ${NATIONAL_TOILET_DATA.length} ä¸ªå…¬å•æ•°æ®`);
            updateStatistics();
        }

        // 2. åˆ›å»ºå…¬å•æ ‡è®°
        function createToiletMarker(toilet) {
            let color = '#3498db';
            let icon = 'ğŸš»';

            if (toilet.type === 'accessible') {
                color = '#e74c3c';
                icon = 'â™¿';
            } else if (toilet.type === 'mother') {
                color = '#9b59b6';
                icon = 'ğŸ‘¶';
            }

            const marker = new AMap.Marker({
                position: [toilet.lng, toilet.lat],
                title: `${toilet.name} (${toilet.city}) - çƒ­åº¦: ${toilet.popularity}`,
                content: `
                    <div style="background: ${color}; color: white; 
                         width: 36px; height: 36px; border-radius: 50%; 
                         display: flex; align-items: center; justify-content: center;
                         font-size: 18px; font-weight: bold; box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                         border: 2px solid white; cursor: pointer;">
                        ${icon}
                    </div>
                `,
                offset: new AMap.Pixel(-18, -18)
            });

            // ç»‘å®šç‚¹å‡»äº‹ä»¶
            marker.on('click', function () {
                showToiletInfo(toilet, marker.getPosition());
                document.getElementById('selectToilet').value = toilet.id;
            });

            return marker;
        }

        // ============ WMS & helpers ============
        function tileXYZToBBox4326(x, y, z) {
            // è¿”å› [minx, miny, maxx, maxy] in lon/lat (EPSG:4326)
            const n = Math.pow(2, z);
            const lon_left = x / n * 360 - 180;
            const lon_right = (x + 1) / n * 360 - 180;

            function tileYToLat(y, z) {
                const n = Math.pow(2, z);
                const lat_rad = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n)));
                return lat_rad * 180 / Math.PI;
            }

            const lat_top = tileYToLat(y, z);
            const lat_bottom = tileYToLat(y + 1, z);

            const minx = lon_left;
            const miny = lat_bottom;
            const maxx = lon_right;
            const maxy = lat_top;
            return [minx, miny, maxx, maxy];
        }

        async function addQgisWmsLayer() {
            if (!map) return;
            if (qgisWmsLayer) return;

            updateStatus('æ­£åœ¨æ¢æµ‹ QGIS WMS å‚æ•°...', false);
            console.info('[QGIS WMS] å¼€å§‹æ¢æµ‹å¯ç”¨çš„ VERSION/CRS ç»„åˆ');

            // å°å·¥å…·ï¼šå°è¯•åŠ è½½å›¾ç‰‡ï¼ŒæˆåŠŸè¿”å› trueï¼Œå¤±è´¥è¿”å› false
            function attemptLoadImage(url, timeout = 4000) {
                return new Promise((resolve) => {
                    try {
                        window._qgisWmsProbeLog = window._qgisWmsProbeLog || [];
                        const img = new Image();
                        img.crossOrigin = 'anonymous';
                        let timer = setTimeout(() => {
                            img.onload = img.onerror = null;
                            window._qgisWmsProbeLog.push({ url, type: 'image', ok: false, note: 'timeout' });
                            try { if (typeof updateWmsProbePanel === 'function') updateWmsProbePanel(); } catch(e){}
                            resolve(false);
                        }, timeout);
                        img.onload = function () {
                            clearTimeout(timer);
                            window._qgisWmsProbeLog.push({ url, type: 'image', ok: true });
                            try { if (typeof updateWmsProbePanel === 'function') updateWmsProbePanel(); } catch(e){}
                            resolve(true);
                        };
                        img.onerror = function () {
                            clearTimeout(timer);
                            window._qgisWmsProbeLog.push({ url, type: 'image', ok: false });
                            try { if (typeof updateWmsProbePanel === 'function') updateWmsProbePanel(); } catch(e){}
                            resolve(false);
                        };
                        img.src = url;
                    } catch (e) {
                        console.debug('[QGIS WMS] attemptLoadImage å¼‚å¸¸', e);
                        window._qgisWmsProbeLog = window._qgisWmsProbeLog || [];
                        window._qgisWmsProbeLog.push({ url, type: 'image', ok: false, note: 'exception' });
                        resolve(false);
                    }
                });
            }

            // æ ¹æ® tile x/y/z ä¸æŒ‡å®šç»„åˆç”Ÿæˆç“¦ç‰‡ URL
            function buildWmsUrlForTile(x, y, z, combo) {
                let bboxArr;
                if (combo.crs === 'EPSG:4326') {
                    const b = tileXYZToBBox4326(x, y, z); // [minx, miny, maxx, maxy]
                    if (combo.bboxOrder === 'latlon') {
                        // WMS 1.3.0 with EPSG:4326 expects lat,lon order (miny,minx,maxy,maxx)
                        bboxArr = [b[1], b[0], b[3], b[2]];
                    } else {
                        // lon,lat order (minx,miny,maxx,maxy)
                        bboxArr = [b[0], b[1], b[2], b[3]];
                    }
                } else {
                    // EPSG:3857 (meters)
                    const b = tileXYZToBBox3857(x, y, z); // [minx, miny, maxx, maxy]
                    bboxArr = [b[0], b[1], b[2], b[3]];
                }

                const bbox = bboxArr.join(',');
                const params = [];
                params.push('SERVICE=WMS');
                params.push(`VERSION=${combo.version}`);
                params.push('REQUEST=GetMap');
                params.push(`LAYERS=${encodeURIComponent(combo.layers)}`);
                params.push('STYLES=');
                params.push(`FORMAT=${combo.format ? encodeURIComponent(combo.format) : 'image/png'}`);
                params.push('TRANSPARENT=true');
                params.push(`${combo.crsParam}=${combo.crs}`);
                params.push(`BBOX=${bbox}`);
                params.push('WIDTH=256');
                params.push('HEIGHT=256');
                return `${QGIS_WMS_BASE}?${params.join('&')}`;
            }

            // å…ˆå°è¯•ä½¿ç”¨ GetCapabilities è·å–æœåŠ¡å…ƒä¿¡æ¯ï¼ˆå¦‚æœå…è®¸ CORSï¼‰ä»¥è·å¾—ç²¾ç¡®çš„ layer åç§°ä¸æ”¯æŒçš„ CRS
            async function probeGetCapabilities(baseUrl) {
                const versions = ['1.3.0', '1.1.1'];
                for (const v of versions) {
                    try {
                        const url = `${baseUrl.replace(/\/?$/, '')}?SERVICE=WMS&REQUEST=GetCapabilities&VERSION=${v}`;
                        console.debug('[QGIS WMS] å°è¯• GetCapabilities:', url);
                        const resp = await fetch(url, { method: 'GET', mode: 'cors' });
                        if (!resp.ok) { console.debug('[QGIS WMS] GetCapabilities è¿”å›çŠ¶æ€:', resp.status); continue; }
                        const text = await resp.text();
                        const parser = new DOMParser();
                        const xml = parser.parseFromString(text, 'application/xml');
                        const layerElems = Array.from(xml.getElementsByTagName('Layer'));
                        const layerNames = new Set();
                        const supportedCRS = new Set();

                        layerElems.forEach(layer => {
                            const n = layer.getElementsByTagName('Name')[0];
                            if (n && n.textContent) layerNames.add(n.textContent.trim());
                            // æ”¯æŒ CRS/SRS æ ‡ç­¾
                            const crsTags = layer.getElementsByTagName('CRS');
                            const srsTags = layer.getElementsByTagName('SRS');
                            Array.from(crsTags).forEach(c => c.textContent && supportedCRS.add(c.textContent.trim()));
                            Array.from(srsTags).forEach(c => c.textContent && supportedCRS.add(c.textContent.trim()));
                        });

                        // å¦‚æœé¡¶å±‚ Layer æ²¡æœ‰ Nameï¼Œåˆ™è¯•ä» Capability/Layer ä¸‹å¯»æ‰¾
                        if (layerNames.size === 0) {
                            const names = Array.from(xml.getElementsByTagName('Name'));
                            names.forEach(n => n.textContent && layerNames.add(n.textContent.trim()));
                        }

                        if (layerNames.size > 0) {
                            return { version: v, layerNames: Array.from(layerNames), supportedCRS: Array.from(supportedCRS) };
                        }
                    } catch (e) {
                        console.debug('[QGIS WMS] GetCapabilities è¯·æ±‚å¤±è´¥æˆ–è¢« CORS é˜»æ­¢:', e);
                    }
                }
                return null;
            }

            // æ„å»ºä¸€ç³»åˆ—å€™é€‰ layer åç§°å’Œ base URL å˜ä½“
            const baseVariants = [QGIS_WMS_BASE, QGIS_WMS_BASE.replace(/\/?$/, ''), QGIS_WMS_BASE.replace(/\/?$/, '') + '/wms'];
            const defaultLayer = getDefaultWmsLayerName();
            // å¢åŠ  QGIS é¡¹ç›®ä¸­å¸¸è§çš„ä¸­/è‹±åç§°å€™é€‰ï¼ˆä¾‹å¦‚ä½ æä¾›çš„ï¼š`ä¸­å›½çœçº¿`ï¼ˆçº¿ï¼‰å’Œ `ä¸­å›½çœ`ï¼ˆé¢ï¼‰ï¼‰ï¼Œå¹¶åŒ…å«éƒ¨åˆ†å‰ç¼€å˜ä½“
            const layerCandidates = [
                defaultLayer,
                `smilejxl:${defaultLayer}`,
                `${defaultLayer}:${defaultLayer}`,
                'ä¸­å›½çœçº¿',
                'ä¸­å›½çœ',
                `smilejxl:ä¸­å›½çœçº¿`,
                `smilejxl:ä¸­å›½çœ`
            ];
            const formatCandidates = ['image/png', 'image/png8', 'image/jpeg'];

            // ä¸­å¿ƒæ ·ä¾‹ç“¦ç‰‡
            let sampleZ = Math.max(2, Math.round(map.getZoom() || 4));
            const center = map.getCenter();
            const n = Math.pow(2, sampleZ);
            const xt = Math.floor((center.lng + 180) / 360 * n);
            const latRad = center.lat * Math.PI / 180;
            const yt = Math.floor((1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad)) / Math.PI) / 2 * n);

            let chosen = null;

            // 1) ä¼˜å…ˆä½¿ç”¨ GetCapabilities çš„å‘ç°ç»“æœ
            for (const base of baseVariants) {
                const cap = await probeGetCapabilities(base);
                if (cap) {
                    console.debug('[QGIS WMS] GetCapabilities å‘ç°ï¼š', cap);
                    // ä¼˜å…ˆä½¿ç”¨ä¸é»˜è®¤Layerä¸€è‡´çš„é¡¹ï¼Œå¦åˆ™ä½¿ç”¨ç¬¬ä¸€ä¸ªå¯ç”¨çš„ layer
                    let candidateLayer = cap.layerNames.find(n => n === defaultLayer) || cap.layerNames[0];
                    // å°è¯•ä½¿ç”¨ capabilities ä¸­çš„ crsï¼ˆä¼˜å…ˆ EPSG:4326 / EPSG:3857ï¼‰
                    const preferCRS = cap.supportedCRS.includes('EPSG:4326') ? 'EPSG:4326' : (cap.supportedCRS.includes('EPSG:3857') ? 'EPSG:3857' : cap.supportedCRS[0] || 'EPSG:4326');

                    const candidates = [
                        { version: cap.version === '1.3.0' ? '1.3.0' : '1.1.1', crsParam: cap.version === '1.3.0' ? 'CRS' : 'SRS', crs: preferCRS, bboxOrder: (cap.version === '1.3.0' && preferCRS === 'EPSG:4326') ? 'latlon' : 'lonlat', layers: candidateLayer }
                    ];

                    for (const combo of candidates) {
                        const testUrl = buildWmsUrlForTile(xt, yt, sampleZ, combo).replace(QGIS_WMS_BASE, base);
                        console.debug('[QGIS WMS] ä½¿ç”¨ Capabilities æµ‹è¯• URL:', testUrl);
                        updateStatus(`æµ‹è¯• WMS (GetCapabilities) ${combo.version} / ${combo.crs} ...`, false);
                        try {
                            // é¦–å…ˆå°è¯• fetch ä»¥ä¾¿è·å– HTTP çŠ¶æ€å’Œå“åº”ä¿¡æ¯ï¼ˆè‹¥è¢« CORS é˜»æ­¢åˆ™æŠ›å‡ºï¼‰
                            const resp = await fetch(testUrl, { method: 'GET', mode: 'cors' });
                            window._qgisWmsProbeLog = window._qgisWmsProbeLog || [];
                            window._qgisWmsProbeLog.push({ url: testUrl, type: 'fetch', status: resp.status });
                            if (resp.ok) {
                                const contentType = resp.headers.get('content-type') || '';
                                if (contentType.includes('image')) {
                                    chosen = combo; chosen.sampleUrl = testUrl; chosen.base = base; break;
                                } else {
                                    const body = await resp.text();
                                    console.debug('[QGIS WMS] éå›¾åƒå“åº”è¿”å›ï¼š', resp.status, body.slice ? body.slice(0, 200) : body);
                                }
                            } else {
                                const body = await resp.text().catch(() => '');
                                console.debug('[QGIS WMS] fetch è¿”å›çŠ¶æ€', resp.status, body.slice ? body.slice(0,200) : body);
                            }
                        } catch (e) {
                            console.debug('[QGIS WMS] fetch è¢«é˜»æ­¢æˆ–å¤±è´¥ï¼Œå›é€€åˆ° image åŠ è½½æ£€æµ‹', e);
                            window._qgisWmsProbeLog = window._qgisWmsProbeLog || [];
                            window._qgisWmsProbeLog.push({ url: testUrl, type: 'fetch', ok: false, error: (e && e.message) || String(e) });
                            const ok = await attemptLoadImage(testUrl);
                            if (ok) { chosen = combo; chosen.sampleUrl = testUrl; chosen.base = base; break; }
                        }
                    }
                    if (chosen) break;
                }
            }

            // 2) å¦‚æœ GetCapabilities æœªèƒ½æä¾›ä¿¡æ¯æˆ–æœªæ‰¾åˆ°å¯ç”¨ç»„åˆï¼Œåˆ™è¿›è¡Œæ‰©å±•å°è¯•ï¼ˆlayer å˜ä½“ + æ ¼å¼å˜ä½“ï¼‰
            if (!chosen) {
                console.info('[QGIS WMS] æœªé€šè¿‡ GetCapabilities ç¡®è®¤å¯ç”¨ç»„åˆï¼Œè¿›è¡Œæ‰©å±•å°è¯•');
                const versions = ['1.3.0', '1.1.1'];
                let attempts = 0;
                for (const base of baseVariants) {
                    for (const layerName of layerCandidates) {
                        for (const version of versions) {
                            for (const crs of ['EPSG:4326', 'EPSG:3857']) {
                                for (const fmt of formatCandidates) {
                                    if (attempts++ > 30) break; // é™åˆ¶å°è¯•æ¬¡æ•°ï¼Œé¿å…æ— é™å¾ªç¯
                                    const combo = {
                                        version,
                                        crsParam: version === '1.3.0' ? 'CRS' : 'SRS',
                                        crs,
                                        bboxOrder: (version === '1.3.0' && crs === 'EPSG:4326') ? 'latlon' : 'lonlat',
                                        layers: layerName,
                                        format: fmt
                                    };
                                    // build URL and try fetch first
                                    const testUrl = (function () {
                                        let url = buildWmsUrlForTile(xt, yt, sampleZ, combo);
                                        // replace default base with variant
                                        return url.replace(QGIS_WMS_BASE, base).replace('FORMAT=image/png', `FORMAT=${encodeURIComponent(fmt)}`);
                                    })();

                                    console.debug('[QGIS WMS] æ‰©å±•æµ‹è¯• URL:', testUrl);
                                    updateStatus(`å°è¯• WMS: ${version} ${crs} ${layerName} ${fmt}`, false);
                                    try {
                                        const resp = await fetch(testUrl, { method: 'GET', mode: 'cors' });
                                        window._qgisWmsProbeLog = window._qgisWmsProbeLog || [];
                                        window._qgisWmsProbeLog.push({ url: testUrl, type: 'fetch', status: resp.status });
                                        if (resp.ok) {
                                            const contentType = resp.headers.get('content-type') || '';
                                            if (contentType.includes('image')) {
                                                chosen = combo; chosen.sampleUrl = testUrl; chosen.base = base; break;
                                            }
                                        } else {
                                            const body = await resp.text().catch(() => '');
                                            console.debug('[QGIS WMS] fetch è¿”å›(é200)ï¼š', resp.status, body.slice ? body.slice(0,200) : body);
                                        }
                                    } catch (e) {
                                        window._qgisWmsProbeLog = window._qgisWmsProbeLog || [];
                                        window._qgisWmsProbeLog.push({ url: testUrl, type: 'fetch', ok: false, error: (e && e.message) || String(e) });
                                        const ok = await attemptLoadImage(testUrl);
                                        if (ok) { chosen = combo; chosen.sampleUrl = testUrl; chosen.base = base; break; }
                                    }
                                }
                                if (chosen) break;
                            }
                            if (chosen) break;
                        }
                        if (chosen) break;
                    }
                    if (chosen || attempts > 30) break;
                }
            }

            if (!chosen) {
                console.warn('[QGIS WMS] æ¢æµ‹åæœªæ‰¾åˆ°å¯ç”¨ WMS å‚æ•°ç»„åˆï¼Œä½¿ç”¨é»˜è®¤ç»„åˆç»§ç»­åŠ è½½ï¼ˆå¯èƒ½ä»ä¼š 400ï¼‰');
                updateStatus('WMS æ¢æµ‹æœªæ‰¾åˆ°å¯ç”¨ç»„åˆï¼Œä½¿ç”¨é»˜è®¤å‚æ•°åŠ è½½ï¼ˆå¦‚æœä» 400ï¼Œè¯·æä¾›å¤±è´¥è¯·æ±‚ URLï¼‰', true);
                chosen = { version: '1.1.1', crsParam: 'SRS', crs: 'EPSG:4326', bboxOrder: 'lonlat', layers: getDefaultWmsLayerName() };
            } else {
                console.info('[QGIS WMS] é€‰å®šç»„åˆï¼š', chosen);
                updateStatus(`WMS å‚æ•°æ¢æµ‹æˆåŠŸï¼šVERSION=${chosen.version}, ${chosen.crsParam}=${chosen.crs}, LAYERS=${chosen.layers}`, false);
            }

            // å°†æ¢æµ‹ç»“æœå­˜å‚¨åˆ° wmsConfigï¼ˆä¾¿äºè°ƒè¯•ï¼‰
            try { wmsConfig.endpoint = chosen.base || QGIS_WMS_BASE; wmsConfig.version = chosen.version; wmsConfig.crs = chosen.crs; wmsConfig.layer = chosen.layers; } catch (e) {}
            try { if (typeof updateWmsProbePanel === 'function') updateWmsProbePanel(); } catch(e) { console.debug('updateWmsProbePanel è°ƒç”¨å¤±è´¥', e); }


            // åˆ›å»º TileLayerï¼Œä½¿ç”¨é€‰å®šçš„ç»„åˆæ„å»ºç“¦ç‰‡ URL
            qgisWmsLayer = new AMap.TileLayer({
                getTileUrl: function (x, y, z) {
                    try {
                        let url = buildWmsUrlForTile(x, y, z, chosen);
                        if (chosen && chosen.base) url = url.replace(QGIS_WMS_BASE, chosen.base);
                        // å¦‚æœå¯ç”¨äº†ä»£ç†ï¼Œåˆ™å°†å®é™… URL æ”¾åˆ°ä»£ç†å‰ç¼€åï¼ˆä¾‹å¦‚ proxy?url=ENCODED_URLï¼‰
                        if (window._useWmsProxy && window._wmsProxyUrl) {
                            const proxy = window._wmsProxyUrl;
                            const sep = proxy.includes('?') ? '&' : '?';
                            return `${proxy}${sep}url=${encodeURIComponent(url)}`;
                        }
                        return url;
                    } catch (e) {
                        console.debug('[QGIS WMS] getTileUrl æ„å»ºå¤±è´¥', e);
                        return '';
                    }
                },
                zIndex: 6,
                opacity: 0.85
            });

            try {
                map.add(qgisWmsLayer);
                console.info('[QGIS WMS] å›¾å±‚å·²æ·»åŠ ï¼ˆç»„åˆï¼š', chosen, ')');
                if (chosen.sampleUrl) console.debug('[QGIS WMS] æˆåŠŸæ ·ä¾‹ URL:', chosen.sampleUrl);
            } catch (e) {
                console.error('[QGIS WMS] æ·»åŠ å›¾å±‚å¤±è´¥', e);
                updateStatus('æ·»åŠ  WMS å›¾å±‚å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°æ—¥å¿—', true);
            }
        }

        function removeQgisWmsLayer() {
            if (qgisWmsLayer && map) {
                try { map.remove(qgisWmsLayer); } catch (e) {}
                qgisWmsLayer = null;
                console.info('[QGIS WMS] å›¾å±‚å·²ç§»é™¤');
            }
        }

        function toggleQgisWms(enable) {
            isQgisWmsEnabled = !!enable;
            if (isQgisWmsEnabled) addQgisWmsLayer(); else removeQgisWmsLayer();
        }

        // Heatmap æ›´æ–°ï¼ˆå¢å¼ºï¼‰ï¼šåœ¨åœ°å›¾äº¤äº’æ—¶å»¶è¿Ÿæ›´æ–°ï¼Œå¹¶åšæ›´é•¿çš„é˜²æŠ–ä»¥å‡å°‘ canvas readback è­¦å‘Š
        function requestHeatmapUpdate(data, delay = 600) {
            if (!heatmapLayer) return;

            // å¦‚æœæ­£åœ¨äº¤äº’ï¼ˆæ‹–åŠ¨/ç¼©æ”¾ï¼‰ï¼Œè®°å½•ä¸ºå¾…å¤„ç†æ•°æ®ï¼Œç­‰äº¤äº’ç»“æŸåå†æ›´æ–°
            if (mapIsInteracting) {
                _pendingHeatmapData = data;
                return;
            }

            // å¦åˆ™ä½¿ç”¨é˜²æŠ–å®šæ—¶å™¨æ›´æ–°
            if (_heatmapUpdateTimer) clearTimeout(_heatmapUpdateTimer);
            _heatmapUpdateTimer = setTimeout(() => {
                try {
                    if (heatmapLayer.setData) {
                        heatmapLayer.setData(data);
                    } else if (heatmapLayer.setDataSet) {
                        // v1.4 æ¥å£æ¥å— {data: [...]}
                        if (data && data.data) {
                            heatmapLayer.setDataSet(data);
                        } else {
                            heatmapLayer.setDataSet({ data });
                        }
                    }
                } catch (e) {
                    console.warn('Heatmap æ›´æ–°å¤±è´¥ï¼š', e);
                } finally {
                    _heatmapUpdateTimer = null;
                }
            }, delay);
        }

        // åœ¨äº¤äº’ç»“æŸæ—¶ç«‹å³åº”ç”¨ä¸€æ¬¡å¯ç”¨çš„å¾…å¤„ç†æ•°æ®ï¼ˆæ— å»¶è¿Ÿï¼‰
        function applyPendingHeatmapIfAny() {
            if (!heatmapLayer) { _pendingHeatmapData = null; return; }
            if (_pendingHeatmapData) {
                try {
                    const d = _pendingHeatmapData;
                    _pendingHeatmapData = null;
                    if (heatmapLayer.setData) heatmapLayer.setData(d);
                    else if (heatmapLayer.setDataSet) heatmapLayer.setDataSet(d && d.data ? d : { data: d });
                } catch (e) {
                    console.warn('åº”ç”¨å¾…å¤„ç†çƒ­åŠ›å›¾æ•°æ®å¤±è´¥ï¼š', e);
                }
            }
        }

        // å…¼å®¹ï¼šæ—§è°ƒç”¨ scheduleHeatmapUpdate -> æ˜ å°„åˆ° requestHeatmapUpdate
        function scheduleHeatmapUpdate(data, delay) {
            // ä¿æŒ API å‘åå…¼å®¹ï¼šæ—§ä»£ç ä½¿ç”¨ scheduleHeatmapUpdate
            return requestHeatmapUpdate(data, delay);
        }

        // æ›´æ–°å³ä¾§é¢æ¿ä¸­çš„çƒ­åŠ›å›¾ä¿¡æ¯ï¼ˆåŠå¾„ä¸å½“å‰åœ°å›¾èŒƒå›´ï¼‰
        function updateHeatmapInfo() {
            const el = document.getElementById('heatmapInfo');
            if (!el) return;
            try {
                const radius = (typeof currentHeatmapRadius !== 'undefined' && currentHeatmapRadius !== null) ? currentHeatmapRadius : 0;
                let boundsText = '-';
                if (map && map.getBounds) {
                    const b = map.getBounds();
                    if (b) {
                        const sw = b.getSouthWest();
                        const ne = b.getNorthEast();
                        boundsText = `${sw.lng.toFixed(4)},${sw.lat.toFixed(4)} â†’ ${ne.lng.toFixed(4)},${ne.lat.toFixed(4)}`;
                    }
                }
                el.textContent = `çƒ­åŠ›å›¾åŠå¾„: ${radius}px â€” å½“å‰åœ°å›¾èŒƒå›´: ${boundsText}`;
            } catch (e) {
                console.debug('updateHeatmapInfo å¼‚å¸¸', e);
                el.textContent = `çƒ­åŠ›å›¾åŠå¾„: ${currentHeatmapRadius}px`;
            }
        }

        // 3. ä¿®å¤ï¼šåˆ‡æ¢åœ°å›¾æ¨¡å¼ï¼ˆæ ¸å¿ƒä¿®å¤å«æ˜Ÿå›¾æ˜¾ç¤ºï¼Œå¢å¼ºçƒ­åŠ›å›¾ï¼‰
        function switchMapMode(mode) {
            // å…³é”®ï¼šå…ˆç§»é™¤æ‰€æœ‰ç°æœ‰åŸºç¡€å›¾å±‚ï¼ˆé¿å…è¦†ç›–ï¼‰
            const allLayers = map.getLayers();
            allLayers.forEach(layer => {
                // åªä¿ç•™æ§ä»¶/æ ‡è®°å›¾å±‚ï¼Œç§»é™¤åœ°å›¾ç“¦ç‰‡/çƒ­åŠ›å›¾å›¾å±‚
                if (layer instanceof AMap.TileLayer || layer instanceof AMap.HeatMap) {
                    map.remove(layer);
                }
            });

            // éšè—çƒ­åŠ›å›¾å›¾ä¾‹
            document.getElementById('heatmapLegend').style.display = 'none';

            switch (mode) {
                case 'normal':
                    // åŠ è½½æ ‡å‡†åœ°å›¾ï¼ˆçŸ¢é‡å›¾ï¼‰
                    const normalLayer = new AMap.TileLayer({
                        url: 'https://webst0{1,2,3,4}.is.autonavi.com/appmaptile?style=7&x={x}&y={y}&z={z}&key=' + CONFIG.AMAP_JS_KEY,
                        zIndex: 1
                    });
                    map.add(normalLayer);
                    heatmapLayer = null;
                    if (isQgisWmsEnabled) addQgisWmsLayer();
                    updateStatus('å·²åˆ‡æ¢è‡³æ ‡å‡†åœ°å›¾');
                    break;

                case 'satellite':
                    try {
                        // æ–¹æ¡ˆ1ï¼šä¼˜å…ˆä½¿ç”¨å®˜æ–¹å«æ˜Ÿå›¾å±‚ï¼ˆéœ€æƒé™ï¼‰
                        const satelliteLayer = new AMap.TileLayer.Satellite({ zIndex: 1 });
                        map.add(satelliteLayer);
                        // å åŠ è·¯ç½‘ï¼ˆé¿å…çº¯å«æ˜Ÿå›¾æ— é“è·¯æ ‡æ³¨ï¼‰
                        const roadNetLayer = new AMap.TileLayer.RoadNet({ zIndex: 2 });
                        map.add(roadNetLayer);
                        if (isQgisWmsEnabled) addQgisWmsLayer();
                        updateStatus('å·²åˆ‡æ¢è‡³å«æ˜Ÿå½±åƒï¼ˆå«è·¯ç½‘æ ‡æ³¨ï¼‰');
                    } catch (e) {
                        console.warn('å®˜æ–¹å«æ˜Ÿå›¾å±‚åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨ç“¦ç‰‡ç›´è¿æ¨¡å¼:', e);
                        // æ–¹æ¡ˆ2ï¼šç“¦ç‰‡ç›´è¿æ¨¡å¼ï¼ˆæ— éœ€æƒé™ï¼Œç¨³å®šæ˜¾ç¤ºï¼‰
                        const satelliteTileLayer = new AMap.TileLayer({
                            zIndex: 1,
                            getTileUrl: (x, y, z) => {
                                // å«æ˜Ÿç“¦ç‰‡URLæ¨¡æ¿ï¼ˆstyle=6ä»£è¡¨å«æ˜Ÿå›¾ï¼‰
                                const subdomain = ['1', '2', '3', '4'][Math.floor(Math.random() * 4)];
                                return `https://webst0${subdomain}.is.autonavi.com/appmaptile?style=6&x=${x}&y=${y}&z=${z}&key=${CONFIG.AMAP_JS_KEY}`;
                            }
                        });
                        map.add(satelliteTileLayer);
                        // å åŠ è·¯ç½‘ï¼ˆæ˜¾ç¤ºé“è·¯åç§°ï¼‰
                        const roadLayer = new AMap.TileLayer.RoadNet({ zIndex: 2 });
                        map.add(roadLayer);
                        updateStatus('å·²åˆ‡æ¢è‡³å«æ˜Ÿå½±åƒï¼ˆç¨³å®šç“¦ç‰‡æ¨¡å¼ï¼‰');
                    }
                    heatmapLayer = null;
                    break;

                case 'heatmap':
                    showDarkHeatmap();
                    break;
            }
        }

        // 4. å¢å¼ºï¼šæ˜¾ç¤ºæ·±è‰²çƒ­åŠ›å›¾ï¼ˆæ–°å¢åŠ¨æ€åŠå¾„ã€å›¾ä¾‹æ˜¾ç¤ºï¼‰
        // å¢å¼ºç‰ˆï¼šæ·±è‰²çƒ­åŠ›å›¾åˆå§‹åŒ–ï¼ˆä¿®å¤åŠ è½½å¤±è´¥ï¼‰
        function showDarkHeatmap() {
            // å…ˆç§»é™¤ç°æœ‰çƒ­åŠ›å›¾
            if (heatmapLayer) {
                map.remove(heatmapLayer);
                heatmapLayer = null;
                document.getElementById('heatmapLegend').style.display = 'none';
                updateStatus('å·²å…³é—­çƒ­åŠ›å›¾');
                return;
            }

            // å¼ºåˆ¶æ£€æŸ¥AMapå¯¹è±¡æ˜¯å¦å­˜åœ¨
            if (typeof AMap === 'undefined') {
                updateStatus('é«˜å¾·åœ°å›¾APIæœªåŠ è½½å®Œæˆ', true);
                return;
            }

            // æ–¹æ¡ˆ1ï¼šä½¿ç”¨v2.0å…¼å®¹å†™æ³•åŠ è½½HeatMapæ’ä»¶
            AMap.plugin(['AMap.HeatMap'], function () {
                // å»¶è¿Ÿ500msç¡®ä¿æ’ä»¶å®Œå…¨åŠ è½½
                setTimeout(() => {
                    try {
                        // 1. å…ˆéªŒè¯HeatMapç±»æ˜¯å¦å­˜åœ¨
                        if (typeof AMap.HeatMap !== 'function') {
                            updateStatus('çƒ­åŠ›å›¾æ’ä»¶åŠ è½½å¤±è´¥ï¼šAMap.HeatMapæœªå®šä¹‰', true);
                            // é™çº§æ–¹æ¡ˆï¼šå°è¯•æ—§ç‰ˆç±»å
                            if (typeof AMap.Heatmap === 'function') {
                                updateStatus('å°è¯•ä½¿ç”¨æ—§ç‰ˆçƒ­åŠ›å›¾ç±»å', false);
                                initHeatmap(AMap.Heatmap);
                            }
                            return;
                        }

                        // 2. åˆå§‹åŒ–çƒ­åŠ›å›¾ï¼ˆå…¼å®¹v2.0ï¼‰
                        initHeatmap(AMap.HeatMap);

                    } catch (error) {
                        console.error('çƒ­åŠ›å›¾åˆå§‹åŒ–å¼‚å¸¸:', error);
                        updateStatus(`çƒ­åŠ›å›¾åŠ è½½å¤±è´¥ï¼š${error.message}`, true);
                        // ç»ˆæé™çº§ï¼šæ˜¾ç¤ºé™æ€çƒ­åŠ›å›¾æ ‡è®°
                        showStaticHeatmapMarkers();
                    }
                }, 500);
            });

            // æ ¸å¿ƒåˆå§‹åŒ–é€»è¾‘ï¼ˆæŠ½ç¦»ä¸ºå‡½æ•°ï¼‰
            function initHeatmap(HeatMapClass) {
                // å‡†å¤‡çƒ­åŠ›å›¾æ•°æ®
                const heatmapData = NATIONAL_TOILET_DATA.map(toilet => ({
                    lng: toilet.lng,
                    lat: toilet.lat,
                    count: toilet.popularity || 50 // çƒ­åº¦å€¼ï¼ˆ0-100ï¼‰
                }));

                // åˆ›å»ºçƒ­åŠ›å›¾å®ä¾‹
                heatmapLayer = new HeatMapClass(map, {
                    radius: currentHeatmapRadius,
                    opacity: [0.2, 0.8], // é™ä½é€æ˜åº¦é¿å…é®æŒ¡åœ°å›¾
                    gradient: { // ç®€åŒ–æ¸å˜é…ç½®ï¼ˆé¿å…å…¼å®¹é—®é¢˜ï¼‰
                        0.1: '#3366FF',
                        0.3: '#33CCCC',
                        0.5: '#99CC00',
                        0.7: '#FFCC33',
                        0.9: '#FF3333'
                    },
                    zIndex: 5
                });

                // è®¾ç½®æ•°æ®ï¼ˆå…¼å®¹v1.4å’Œv2.0ï¼‰ - ä½¿ç”¨èŠ‚æµæ›´æ–°å¹¶åœ¨äº¤äº’æ—¶å»¶è¿Ÿï¼Œé¿å…é¢‘ç¹çš„ canvas readback è­¦å‘Š
                requestHeatmapUpdate(heatmapData);

                // è¯´æ˜ï¼šæŸäº›æµè§ˆå™¨ä¼šå¯¹é¢‘ç¹çš„ getImageData æ“ä½œæç¤ºæ€§èƒ½è­¦å‘Šã€‚å·²åœ¨ Map åˆå§‹åŒ–æ—¶è®¾ç½® renderOptions.willReadFrequently = trueï¼Œ
                // å¹¶ä¸”é€šè¿‡èŠ‚æµæ›´æ–°çƒ­åŠ›å›¾æ¥é™ä½è§¦å‘æ¦‚ç‡ï¼Œå¦‚ä»å‡ºç°å¯å¿½ç•¥ï¼ˆéè‡´å‘½ï¼‰ã€‚

                // æ˜¾ç¤ºå›¾ä¾‹
                document.getElementById('heatmapLegend').style.display = 'block';
                updateStatus(`å·²æ˜¾ç¤ºçƒ­åŠ›å›¾ - åŠå¾„: ${currentHeatmapRadius}px`);
                try { const el = document.getElementById('heatmapInfo'); if (el) el.textContent = `çƒ­åŠ›å›¾åŠå¾„: ${currentHeatmapRadius}px â€” å½“å‰åœ°å›¾èŒƒå›´: è®¡ç®—ä¸­...`; updateHeatmapInfo(); } catch(e) { console.debug('æ›´æ–° heatmapInfo å¼‚å¸¸', e); }
            }

            // é™çº§æ–¹æ¡ˆï¼šé™æ€çƒ­åŠ›å›¾æ ‡è®°ï¼ˆAPIåŠ è½½å¤±è´¥æ—¶å¤‡ç”¨ï¼‰
            function showStaticHeatmapMarkers() {
                NATIONAL_TOILET_DATA.forEach(toilet => {
                    // æ ¹æ®çƒ­åº¦å€¼è®¾ç½®æ ‡è®°é¢œè‰²
                    let color = '#3366FF';
                    if (toilet.popularity > 60) color = '#33CCCC';
                    if (toilet.popularity > 70) color = '#99CC00';
                    if (toilet.popularity > 80) color = '#FFCC33';
                    if (toilet.popularity > 90) color = '#FF3333';

                    const marker = new AMap.Marker({
                        position: [toilet.lng, toilet.lat],
                        content: `<div style="width: ${toilet.popularity / 5}px; height: ${toilet.popularity / 5}px; 
                             background: ${color}; border-radius: 50%; opacity: 0.7;"></div>`,
                        offset: new AMap.Pixel(-toilet.popularity / 10, -toilet.popularity / 10)
                    });
                    map.add(marker);
                    markers.push(marker);
                });
                updateStatus('çƒ­åŠ›å›¾åŠ è½½å¤±è´¥ï¼Œå·²æ˜¾ç¤ºé™æ€çƒ­åº¦æ ‡è®°', true);
            }
        }
        // æ–°å¢ï¼šè°ƒæ•´çƒ­åŠ›å›¾åŠå¾„ï¼ˆä¿®å¤ï¼šæ–¹æ³•è°ƒç”¨ï¼‰
        function adjustHeatmapRadius(newRadius) {
            if (!heatmapLayer) {
                updateStatus('è¯·å…ˆå¯ç”¨çƒ­åŠ›å›¾', true);
                return;
            }

            currentHeatmapRadius = newRadius;
            // ä¿®å¤ï¼šç›´æ¥ä¿®æ”¹é…ç½®å¹¶é‡æ–°æ¸²æŸ“
            heatmapLayer.setOptions({ radius: newRadius });
            // é‡æ–°è®¾ç½®æ•°æ®è§¦å‘é‡ç»˜ï¼ˆèŠ‚æµï¼‰
            const heatmapData = NATIONAL_TOILET_DATA.map(toilet => ({
                lng: toilet.lng,
                lat: toilet.lat,
                count: toilet.popularity || 50
            }));
            scheduleHeatmapUpdate({ data: heatmapData, max: 100 });

            updateStatus(`çƒ­åŠ›å›¾åŠå¾„å·²è°ƒæ•´ä¸º: ${newRadius}px`);
            try { updateHeatmapInfo(); } catch (e) { console.debug('updateHeatmapInfo å¼‚å¸¸', e); }
        }

        // 5. è®¾ç½®å½“å‰ä½ç½®
        function setCurrentPosition(position) {
            currentLocation = position;

            document.getElementById('currentPosition').value =
                `${position[0].toFixed(6)}, ${position[1].toFixed(6)}`;

            if (currentLocationMarker) {
                map.remove(currentLocationMarker);
            }

            currentLocationMarker = new AMap.Marker({
                position: position,
                content: `
                    <div style="background: #2ecc71; color: white; 
                         width: 40px; height: 40px; border-radius: 50%; 
                         display: flex; align-items: center; justify-content: center;
                         font-size: 20px; font-weight: bold; box-shadow: 0 3px 10px rgba(0,0,0,0.3);
                         border: 3px solid white;">
                        ğŸ“
                    </div>
                `,
                offset: new AMap.Pixel(-20, -20),
                zIndex: 100 // ç¡®ä¿å½“å‰ä½ç½®æ ‡è®°åœ¨æœ€ä¸Šå±‚
            });

            map.add(currentLocationMarker);
        }

        // 6. è·å–GPSä½ç½®
        function getGPSLocation() {
            if (!navigator.geolocation) {
                updateStatus('æµè§ˆå™¨ä¸æ”¯æŒåœ°ç†å®šä½', true);
                return;
            }

            updateStatus('æ­£åœ¨è·å–å½“å‰ä½ç½®...');

            navigator.geolocation.getCurrentPosition(
                function (position) {
                    const location = [
                        position.coords.longitude,
                        position.coords.latitude
                    ];
                    setCurrentPosition(location);
                    map.setCenter(location);
                    map.setZoom(Math.min(12, CONFIG.MAX_ZOOM)); // é™åˆ¶ç¼©æ”¾çº§åˆ«
                    updateStatus('GPSå®šä½æˆåŠŸ');
                },
                function (error) {
                    updateStatus('å®šä½å¤±è´¥ï¼Œè¯·æ£€æŸ¥å®šä½æƒé™', true);
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000
                }
            );
        }

        // 7. æ–°å¢ï¼šåˆ›å»ºå¯¼èˆªäººç‰©æ ‡è®°
        function createNavCharacter(position) {
            if (navCharacterMarker) {
                map.remove(navCharacterMarker);
            }

            // åˆ›å»ºå¸¦DOMå…ƒç´ çš„æ ‡è®°ï¼ˆä¿®å¤ï¼šç¡®ä¿èƒ½è·å–åˆ°å…ƒç´ ï¼‰
            const characterDiv = document.createElement('div');
            characterDiv.className = 'nav-character';

            navCharacterMarker = new AMap.Marker({
                position: position,
                content: characterDiv,
                offset: new AMap.Pixel(-20, -20),
                zIndex: 1000 // ç¡®ä¿äººç‰©åœ¨æœ€ä¸Šå±‚
            });

            map.add(navCharacterMarker);
            return navCharacterMarker;
        }

        // 8. æ–°å¢ï¼šå¯¼èˆªåŠ¨ç”»æ ¸å¿ƒå‡½æ•°ï¼ˆä¿®å¤ï¼šDOMå…ƒç´ è·å–ï¼‰
        function animateNavigation() {
            if (isPaused || !isNavigating || navPath.length <= 1) return;

            try {
                // è·å–å½“å‰é€Ÿåº¦ï¼ˆæ ¹æ®äº¤é€šå·¥å…·ç±»å‹ï¼‰
                const speed = CONFIG.ANIMATION_SPEED[currentTransportMode] || CONFIG.ANIMATION_SPEED.walking;

                // è·å–å½“å‰ä½ç½®å’Œä¸‹ä¸€ä¸ªç›®æ ‡ç‚¹ï¼Œå¹¶æ ¡éªŒæœ‰æ•ˆæ€§
                const currentPos = navPath[navCurrentIndex];
                const nextPos = navPath[navCurrentIndex + 1];

                if (!currentPos || !nextPos || !Array.isArray(currentPos) || !Array.isArray(nextPos)) {
                    // æ•°æ®å¼‚å¸¸ï¼Œå®‰å…¨ç»ˆæ­¢å¯¼èˆª
                    console.warn('å¯¼èˆªè·¯å¾„æ•°æ®å¼‚å¸¸ï¼Œåœæ­¢å¯¼èˆª', {currentPos, nextPos, navCurrentIndex, navPathLength: navPath.length});
                    finishNavigation();
                    return;
                }

                // è®¡ç®—ä¸¤ç‚¹ä¹‹é—´çš„è·ç¦»
                const distance = calculateDistance(currentPos, nextPos);

                // å¦‚æœè·ç¦»å¾ˆè¿‘ï¼Œç›´æ¥è·³åˆ°ä¸‹ä¸€ä¸ªç‚¹
                if (distance < 10) {
                    navCurrentIndex++;
                    if (navCharacterMarker) navCharacterMarker.setPosition(nextPos);

                    // æ›´æ–°è¿›åº¦
                    navProgress = (navCurrentIndex / (navPath.length - 1)) * 100;
                    document.getElementById('navProgressBar').style.width = `${navProgress}%`;

                    // å¯¼èˆªå®Œæˆ
                    if (navCurrentIndex >= navPath.length - 1) {
                        finishNavigation();
                        return;
                    }

                    // è®¡ç®—äººç‰©æœå‘ï¼ˆé¢å‘ä¸‹ä¸€ä¸ªç‚¹ï¼‰
                    const angle = calculateAngle(currentPos, nextPos);
                    // ä¿®å¤ï¼šæ­£ç¡®è·å–å¯¼èˆªäººç‰©DOMå…ƒç´ å¹¶è®¾ç½®æ—‹è½¬
                    const characterEl = navCharacterMarker && navCharacterMarker.getContent ? navCharacterMarker.getContent() : null;
                    if (characterEl) {
                        characterEl.style.transform = `rotate(${angle}deg)`;
                    }

                    requestAnimationFrame(animateNavigation);
                    return;
                }

                // è®¡ç®—ç§»åŠ¨æ­¥é•¿
                const stepLng = (nextPos[0] - currentPos[0]) / distance * speed;
                const stepLat = (nextPos[1] - currentPos[1]) / distance * speed;

                // æ›´æ–°äººç‰©ä½ç½®
                const newPos = [currentPos[0] + stepLng, currentPos[1] + stepLat];
                navPath[navCurrentIndex] = newPos; // æ›´æ–°å½“å‰ä½ç½®
                if (navCharacterMarker) navCharacterMarker.setPosition(newPos);

                // æ›´æ–°è¿›åº¦
                navProgress = (navCurrentIndex / (navPath.length - 1)) * 100;
                document.getElementById('navProgressBar').style.width = `${navProgress}%`;

                // è¯·æ±‚ä¸‹ä¸€å¸§
                navAnimationFrame = requestAnimationFrame(animateNavigation);
            } catch (e) {
                console.error('å¯¼èˆªåŠ¨ç”»å‘ç”Ÿå¼‚å¸¸ï¼Œå·²åœæ­¢å¯¼èˆªï¼š', e);
                finishNavigation();
            }
        }



        // 9. æ–°å¢ï¼šè®¡ç®—ä¸¤ç‚¹ä¹‹é—´çš„è§’åº¦ï¼ˆç”¨äºäººç‰©æœå‘ï¼‰
        function calculateAngle(from, to) {
            const dx = to[0] - from[0];
            const dy = to[1] - from[1];
            let angle = Math.atan2(dy, dx) * 180 / Math.PI;
            return angle + 90; // è°ƒæ•´æœå‘ï¼Œè®©äººç‰©é¢å‘ç§»åŠ¨æ–¹å‘
        }

        // 10. æ–°å¢ï¼šä½¿ç”¨é«˜å¾·APIè·å–çœŸå®é“è·¯è·¯å¾„
        function getRealRoadPath(start, end, callback) {
            AMap.plugin('AMap.Driving', function () {
                // æ¸…ç†ä¸Šä¸€æ¬¡çš„ driving è¦†ç›–ï¼ˆå¦‚æœæœ‰ï¼‰
                try { if (drivingService) { drivingService.clear(); drivingService = null; } } catch (e) { console.debug('æ¸…ç† drivingService å¤±è´¥', e); }
                const driving = new AMap.Driving({
                    map: map,
                    policy: AMap.DrivingPolicy.LEAST_TIME
                });
                // ä¿ç•™å¼•ç”¨ä»¥ä¾¿ later å¯ä»¥ clear()
                try { drivingService = driving; } catch (e) { console.debug('è®¾ç½® drivingService å¤±è´¥', e); }

                driving.search(
                    new AMap.LngLat(start[0], start[1]),
                    new AMap.LngLat(end[0], end[1]),
                    (status, result) => {
                        try {
                            if (status === 'complete' && result && result.routes && result.routes.length > 0 && result.routes[0].steps) {
                                const path = [];
                                // æå–æ‰€æœ‰è·¯å¾„ç‚¹ï¼ˆå…¼å®¹ step.path ä¸ºæ•°ç»„æˆ–åˆ†å·åˆ†éš”å­—ç¬¦ä¸²çš„æƒ…å†µï¼‰
                                result.routes[0].steps.forEach(step => {
                                    if (!step || !step.path) return;
                                    if (Array.isArray(step.path)) {
                                        step.path.forEach(pt => {
                                            if (pt && pt.lng !== undefined && pt.lat !== undefined) {
                                                path.push([parseFloat(pt.lng), parseFloat(pt.lat)]);
                                            }
                                        });
                                    } else if (typeof step.path === 'string') {
                                        const pairs = step.path.split(';');
                                        pairs.forEach(pair => {
                                            const [lngStr, latStr] = pair.split(',');
                                            const lng = parseFloat(lngStr);
                                            const lat = parseFloat(latStr);
                                            if (!Number.isNaN(lng) && !Number.isNaN(lat)) {
                                                path.push([lng, lat]);
                                            }
                                        });
                                    }
                                });

                                // å¦‚æœæˆåŠŸè§£æåˆ°æœ‰æ•ˆè·¯å¾„ç‚¹åˆ™è¿”å›ï¼Œå¦åˆ™å…œåº•ä¸ºç›´çº¿
                                if (path.length >= 2) {
                                    callback(path);
                                    return;
                                }
                            }
                        } catch (e) {
                            console.warn('è§£æ Driving è·¯å¾„æ—¶å‡ºé”™ï¼Œå›é€€ä½¿ç”¨ç›´çº¿è·¯å¾„ï¼š', e);
                        }

                        // å¦‚æœè·å–ä¸åˆ°çœŸå®è·¯å¾„æˆ–è§£æå¤±è´¥ï¼Œä½¿ç”¨ç›´çº¿è·¯å¾„å…œåº•
                        callback([start, end]);
                    }
                );
            });
        }

        // 11. å¼€å§‹å¯¼èˆªï¼ˆæ–°å¢åŠ¨ç”»é€»è¾‘ï¼‰
        function startNavigation() {
            if (!currentLocation) {
                updateStatus('è¯·å…ˆè®¾ç½®å½“å‰ä½ç½®', true);
                return;
            }

            const toiletId = document.getElementById('selectToilet').value;
            if (!toiletId) {
                updateStatus('è¯·é€‰æ‹©ç›®æ ‡å…¬å•', true);
                return;
            }

            const toilet = NATIONAL_TOILET_DATA.find(t => t.id == toiletId);
            if (!toilet) {
                updateStatus('å…¬å•ä¿¡æ¯ä¸å­˜åœ¨', true);
                return;
            }

            isNavigating = true;
            isPaused = false;
            currentTransportMode = document.getElementById('transportMode').value;
            const destination = [toilet.lng, toilet.lat];

            // æ˜¾ç¤ºå¯¼èˆªä¿¡æ¯
            document.getElementById('navInfo').style.display = 'block';
            document.getElementById('navDestination').textContent = toilet.name;
            document.getElementById('navTransport').textContent = getTransportName(currentTransportMode);
            document.getElementById('btnPauseNavigation').style.display = 'block';
            document.getElementById('navProgress').style.display = 'block';
            document.getElementById('navProgressBar').style.width = '0%';

            // è·å–çœŸå®é“è·¯è·¯å¾„
            getRealRoadPath(currentLocation, destination, (path) => {
                if (!Array.isArray(path) || path.length < 2) {
                    console.warn('getRealRoadPath è¿”å›ä¸å®Œæ•´è·¯å¾„ï¼Œä½¿ç”¨ç›´çº¿è·¯å¾„å…œåº•');
                    path = [currentLocation, destination];
                }

                navPath = path;
                navCurrentIndex = 0;
                navProgress = 0;

                // ç»˜åˆ¶å¯¼èˆªè·¯çº¿
                drawNavigationRoute(path);

                // åˆ›å»ºå¯¼èˆªäººç‰©
                createNavCharacter(currentLocation);

                // è®¡ç®—è·ç¦»å’Œæ—¶é—´
                const distance = calculateDistance(currentLocation, destination);
                const time = calculateTravelTime(distance, currentTransportMode);
                document.getElementById('navDistance').textContent = formatDistance(distance);
                document.getElementById('navTime').textContent = formatTime(time);

                // å¼€å§‹åŠ¨ç”»
                animateNavigation();

                updateStatus(`å¼€å§‹${getTransportName(currentTransportMode)}å¯¼èˆªåˆ°: ${toilet.name}`);
            });
        }

        // 12. ç»˜åˆ¶å¯¼èˆªè·¯çº¿ï¼ˆæ”¯æŒå¤šè·¯å¾„ç‚¹ï¼‰
        function drawNavigationRoute(path) {
            if (navigationLine) {
                map.remove(navigationLine);
            }

            navigationLine = new AMap.Polyline({
                path: path,
                strokeColor: "#3366FF",
                strokeWeight: 6,
                strokeOpacity: 0.8,
                strokeStyle: "solid",
                zIndex: 10 // ç¡®ä¿è·¯çº¿åœ¨æœ€ä¸Šå±‚
            });

            map.add(navigationLine);
            map.setFitView([navigationLine], { padding: [50, 50, 50, 50] });
        }

        // 13. æ–°å¢ï¼šæš‚åœ/ç»§ç»­å¯¼èˆª
        function togglePauseNavigation() {
            isPaused = !isPaused;
            const btn = document.getElementById('btnPauseNavigation');

            if (isPaused) {
                btn.innerHTML = '<<i>â–¶ï¸</</i> ç»§ç»­å¯¼èˆª';
                updateStatus('å¯¼èˆªå·²æš‚åœ');
                if (navAnimationFrame) {
                    cancelAnimationFrame(navAnimationFrame);
                }
            } else {
                btn.innerHTML = '<<i>â¸ï¸</</i> æš‚åœå¯¼èˆª';
                updateStatus(`ç»§ç»­${getTransportName(currentTransportMode)}å¯¼èˆª`);
                animateNavigation();
            }
        }

        // 14. æ–°å¢ï¼šå®Œæˆå¯¼èˆª
        function finishNavigation() {
            isNavigating = false;
            updateStatus(`å¯¼èˆªå®Œæˆï¼å·²åˆ°è¾¾${document.getElementById('navDestination').textContent}`);

            // æ˜¾ç¤ºåˆ°è¾¾æç¤º
            infoWindow.setContent(`
                <div style="padding: 12px; text-align: center;">
                    <div style="font-size: 18px; color: #27ae60; margin-bottom: 8px;">ğŸ‰ å¯¼èˆªå®Œæˆï¼</div>
                    <div style="color: #555;">å·²åˆ°è¾¾ç›®æ ‡å…¬å•</div>
                </div>
            `);
            infoWindow.open(map, navPath[navPath.length - 1]);

            // æ¸…é™¤åŠ¨ç”»å’Œè¿›åº¦æ¡
            if (navAnimationFrame) {
                cancelAnimationFrame(navAnimationFrame);
            }
            document.getElementById('navProgress').style.display = 'none';
            document.getElementById('btnPauseNavigation').style.display = 'none';
        }

        // 15. æœç´¢åŸå¸‚å…¬å•
        function searchCityToilets() {
            const city = document.getElementById('searchCity').value.trim();
            if (!city) {
                updateStatus('è¯·è¾“å…¥åŸå¸‚åç§°', true);
                return;
            }

            updateStatus(`æ­£åœ¨æœç´¢${city}çš„å…¬å•...`);

            // ç­›é€‰è¯¥åŸå¸‚çš„å…¬å•
            const cityToilets = NATIONAL_TOILET_DATA.filter(toilet =>
                toilet.city.includes(city)
            );

            if (cityToilets.length === 0) {
                updateStatus(`æœªæ‰¾åˆ°${city}çš„å…¬å•æ•°æ®`, true);
                return;
            }

            // æ¸…é™¤æ ‡è®°å¹¶æ˜¾ç¤ºè¯¥åŸå¸‚å…¬å•
            clearMarkers();
            cityToilets.forEach(toilet => {
                const marker = createToiletMarker(toilet);
                markers.push(marker);
                map.add(marker);
            });

            // å¦‚æœå½“å‰æ˜¾ç¤ºçƒ­åŠ›å›¾ï¼Œæ›´æ–°çƒ­åŠ›å›¾æ•°æ®ä¸ºå½“å‰åŸå¸‚
            if (heatmapLayer) {
                const heatmapData = cityToilets.map(toilet => ({
                    lng: toilet.lng,
                    lat: toilet.lat,
                    count: toilet.popularity || 50
                }));
                // ä¿®å¤ï¼šä½¿ç”¨èŠ‚æµæ–¹å¼æ›´æ–°çƒ­åŠ›å›¾æ•°æ®ï¼Œé¿å…é¢‘ç¹ canvas è¯»å–è­¦å‘Š
                scheduleHeatmapUpdate({ data: heatmapData, max: 100 });
                updateStatus(`æ‰¾åˆ°${city} ${cityToilets.length} ä¸ªå…¬å•ï¼Œå·²æ›´æ–°çƒ­åŠ›å›¾ï¼ˆèŠ‚æµç”Ÿæ•ˆï¼‰`);
            } else {
                updateStatus(`æ‰¾åˆ°${city} ${cityToilets.length} ä¸ªå…¬å•`);
            }

            // è°ƒæ•´åœ°å›¾è§†é‡
            const lngs = cityToilets.map(t => t.lng);
            const lats = cityToilets.map(t => t.lat);
            const centerLng = (Math.min(...lngs) + Math.max(...lngs)) / 2;
            const centerLat = (Math.min(...lats) + Math.max(...lats)) / 2;

            map.setCenter([centerLng, centerLat]);
            map.setZoom(Math.min(12, CONFIG.MAX_ZOOM)); // é™åˆ¶ç¼©æ”¾çº§åˆ«
        }

        // ============ ä»é«˜å¾·POIæ£€ç´¢å…¬å•ï¼ˆJSONPï¼‰ ============
        // ä¼˜å…ˆä½¿ç”¨ JS API çš„ PlaceSearchï¼ˆä½¿ç”¨ JS Key ä¸ Securityï¼‰ï¼Œå¤±è´¥åˆ™å›é€€åˆ° REST JSONPï¼ˆä½¿ç”¨ REST Keyï¼‰
        function fetchPOIPage(page = 1, timeout = 12000) {
            return new Promise((resolve, reject) => {
                // å†…éƒ¨ï¼šREST JSONP å›é€€å®ç°
                function doJSONPFallback() {
                    const callbackName = 'amap_poi_cb_' + Date.now() + '_' + Math.floor(Math.random() * 10000);
                    let script = document.createElement('script');

                    // è¶…æ—¶ä¿æŠ¤
                    const to = setTimeout(() => {
                        try { delete window[callbackName]; } catch (e) {}
                        if (script && document.body.contains(script)) document.body.removeChild(script);
                        reject(new Error('JSONPè¯·æ±‚è¶…æ—¶'));
                    }, timeout);

                    window[callbackName] = function (data) {
                        try { delete window[callbackName]; } catch (e) {}
                        if (script && document.body.contains(script)) document.body.removeChild(script);
                        clearTimeout(to);
                        resolve(data);
                    };

                    const url = `https://restapi.amap.com/v3/place/text?key=${CONFIG.AMAP_REST_KEY}&keywords=%E5%8E%95%E6%89%AF&city=å…¨å›½&offset=25&page=${page}&output=json&extensions=all&callback=${callbackName}`;
                    console.debug('[POI] JSONP å›é€€ URL:', url);
                    updateStatus(`ä½¿ç”¨ REST JSONP å›é€€ï¼ˆç¬¬${page}é¡µï¼‰ï¼Œå¦‚å¤±è´¥è¯·æ£€æŸ¥ REST Key æƒé™`, true);

                    script.src = url;
                    script.onerror = function (e) {
                        try { delete window[callbackName]; } catch (ex) {}
                        if (script && document.body.contains(script)) document.body.removeChild(script);
                        clearTimeout(to);
                        reject(new Error('JSONPåŠ è½½å¤±è´¥ï¼ˆå¯èƒ½Keyæ— æƒé™æˆ–è¢«é™åˆ¶ï¼‰'));
                    };

                    document.body.appendChild(script);
                }

                // ä¼˜å…ˆï¼šä½¿ç”¨ AMap JS SDK PlaceSearchï¼ˆé¿å… JSONP & REST Key æš´éœ²ï¼‰
                if (typeof AMap !== 'undefined') {
                    // helper to attempt a PlaceSearch call
                    function attemptPlaceSearch() {
                        try {
                            updateStatus(`ä½¿ç”¨ JS API (PlaceSearch) æŸ¥è¯¢ç¬¬${page}é¡µï¼ˆä½¿ç”¨ JS Keyï¼‰`);
                            const placeSearch = new AMap.PlaceSearch({ pageSize: 25, pageIndex: page, city: 'å…¨å›½', extensions: 'all' });
                            let finished = false;
                            const toPlace = setTimeout(() => {
                                if (finished) return;
                                finished = true;
                                reject(new Error('PlaceSearch è¯·æ±‚è¶…æ—¶'));
                            }, timeout);

                            placeSearch.search('å•æ‰€', (status, result) => {
                                if (finished) return;
                                finished = true;
                                clearTimeout(toPlace);
                                if (status === 'complete' && result && result.poiList && result.poiList.pois) {
                                    return resolve({ pois: result.poiList.pois });
                                } else {
                                    console.warn('[POI] PlaceSearch å¤±è´¥ï¼š', status, result);
                                    updateStatus(`PlaceSearch å¤±è´¥ï¼ˆ${status}ï¼‰ï¼Œå°è¯•ä½¿ç”¨ REST JSONP å›é€€`, true);
                                    return doJSONPFallback();
                                }
                            });
                        } catch (e) {
                            console.warn('[POI] PlaceSearch è°ƒç”¨å¼‚å¸¸ï¼Œå›é€€ JSONPï¼š', e);
                            updateStatus('PlaceSearch å¼‚å¸¸ï¼Œå°è¯•ä½¿ç”¨ REST JSONP å›é€€', true);
                            return doJSONPFallback();
                        }
                    }

                    // å¦‚æœ PlaceSearch ä¸å¯ç”¨ï¼Œå°è¯•åŠ¨æ€åŠ è½½æ’ä»¶åå†å°è¯•
                    if (typeof AMap.PlaceSearch !== 'function' && AMap.plugin) {
                        let pluginLoaded = false;
                        try {
                            AMap.plugin(['AMap.PlaceSearch'], function () {
                                pluginLoaded = true;
                                attemptPlaceSearch();
                            });
                        } catch (e) {
                            console.warn('åŠ è½½ PlaceSearch æ’ä»¶å¤±è´¥:', e);
                        }

                        // è¶…æ—¶å›é€€
                        setTimeout(() => {
                            if (!pluginLoaded) {
                                updateStatus('PlaceSearch æ’ä»¶åŠ è½½è¶…æ—¶ï¼Œä½¿ç”¨ REST JSONP å›é€€', true);
                                doJSONPFallback();
                            }
                        }, Math.min(4000, timeout));
                        return;
                    }

                    // å¦‚æœ PlaceSearch å·²å­˜åœ¨ï¼Œç›´æ¥å°è¯•
                    if (typeof AMap.PlaceSearch === 'function') {
                        attemptPlaceSearch();
                        return;
                    }
                }

                // å¦‚æœ JS SDK ä¸å¯ç”¨ï¼Œç›´æ¥ä½¿ç”¨ REST JSONP
                updateStatus('AMap JS API (PlaceSearch) ä¸å¯ç”¨ï¼Œä½¿ç”¨ REST JSONP å›é€€', true);
                doJSONPFallback();
            });
        }

        async function fetchAllToiletsFromGaode(maxPages = 8) {
            updateStatus('æ­£åœ¨ä»é«˜å¾·æ£€ç´¢å…¬å•æ•°æ®â€¦');
            NATIONAL_TOILET_DATA.length = 0; // æ¸…ç©ºæ—§æ•°æ®
            const skippedPOIs = []; // æ”¶é›†æ— æ•ˆä½ç½®çš„ POIï¼Œç¨åå°è¯•åœ°ç†ç¼–ç è¡¥å…¨
            // æš´éœ²ä»¥ä¾¿ UI æ‰‹åŠ¨è§¦å‘è¡¥å…¨
            window._skippedPOIs = skippedPOIs;
            try {
                for (let page = 1; page <= maxPages; page++) {
                    try {
                        const data = await fetchPOIPage(page);
                        if (!data || !data.pois || data.pois.length === 0) break;
                        data.pois.forEach((poi, idx) => {
                            const loc = (poi.location && poi.location.split) ? poi.location.split(',') : [];
                            const lng = parseFloat(loc[0]);
                            const lat = parseFloat(loc[1]);

                            // è‹¥ç»çº¬åº¦ç¼ºå¤±æˆ–éæ³•ï¼Œå…ˆè®°å½•ä»¥ä¾¿åç»­åœ°ç†ç¼–ç è¡¥å…¨
                            if (Number.isNaN(lng) || Number.isNaN(lat)) {
                                console.warn('è·³è¿‡æ— æ•ˆä½ç½®çš„ POIï¼ˆå¾…è¡¥å…¨ï¼‰:', poi && (poi.name || poi.id));
                                skippedPOIs.push(poi);
                                return;
                            }

                            NATIONAL_TOILET_DATA.push({
                                id: poi.id || (`gaode_${page}_${idx}`),
                                name: poi.name || 'æœªçŸ¥å…¬å•',
                                lng, lat,
                                city: poi.pname || poi.cityname || poi.adname || '',
                                type: 'general',
                                popularity: 70,
                                address: poi.address || ''
                            });
                        });
                        // å¦‚æœæœ¬é¡µä¸åˆ°25æ¡ï¼Œè¯´æ˜æœ€åä¸€é¡µ
                        if (data.pois.length < 25) break;
                        await new Promise(r => setTimeout(r, 200)); // å°å»¶è¿Ÿï¼Œé¿å…è¢«é™æµ
                    } catch (e) {
                        console.warn('ç¬¬' + page + 'é¡µæ‹‰å–å¤±è´¥:', e.message || e);
                        updateStatus(`ç¬¬${page}é¡µæ‹‰å–å¤±è´¥ï¼š${e.message || e}ï¼ˆè¯·æ£€æŸ¥JS Key/REST Keyæƒé™æˆ–ç½‘ç»œï¼‰`, true);
                        break;
                    }
                }

                // å¯¹äºæ— åæ ‡çš„ POIï¼Œå°è¯•ç”¨ AMap JS Geocoder è¡¥å…¨ï¼ˆä¼˜å…ˆä½¿ç”¨ JS Keyï¼‰
                if (skippedPOIs.length > 0) {
                    console.debug('[POI] å‘ç°æœªå«åæ ‡çš„ POI æ•°é‡ï¼š', skippedPOIs.length);
                    updateStatus(`å‘ç° ${skippedPOIs.length} æ¡ POI æ— åæ ‡ï¼Œæ­£åœ¨å°è¯•é€šè¿‡ JS Geocoder è¡¥å…¨â€¦`);
                    try {
                        const geocodedCount = await geocodeMissingPOIs(skippedPOIs, 200);
                        if (geocodedCount > 0) {
                            updateStatus(`é€šè¿‡åœ°ç†ç¼–ç è¡¥å…¨ ${geocodedCount} æ¡ POI çš„ä½ç½®`);
                        } else {
                            updateStatus(`å°è¯•ä½¿ç”¨ JS Geocoder è¡¥å…¨åæ ‡å¤±è´¥ï¼ˆ${skippedPOIs.length} æ¡ï¼‰ï¼Œè¯·æ£€æŸ¥ JS Key æƒé™æˆ–è€ƒè™‘åç«¯æ‰¹é‡åœ°ç†ç¼–ç `, true);
                        }
                        // æ˜¾ç¤ºè°ƒè¯•é¢æ¿ï¼Œä¾¿äºäº†è§£å“ªäº› POI å°šæœªè¡¥å…¨
                        showDebugPanel(skippedPOIs, geocodedCount);
                    } catch (e) {
                        console.warn('åœ°ç†ç¼–ç è¡¥å…¨è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯ï¼š', e);
                    }
                }

                if (NATIONAL_TOILET_DATA.length === 0) {
                    updateStatus('æœªèƒ½ä»é«˜å¾·æ£€ç´¢åˆ°å…¬å•æ•°æ®ï¼ˆPlaceSearch/REST JSONP å‡å¤±è´¥ï¼‰ã€‚è¯·æ£€æŸ¥ï¼š1) JS Key æƒé™ä¸å®‰å…¨é…ç½®ï¼ˆAMAP_JS_KEY + AMAP_JS_SECURITYï¼‰ï¼›2) REST Key æƒé™ï¼ˆAMAP_REST_KEYï¼‰ï¼›æˆ–è€ƒè™‘ä½¿ç”¨åç«¯ä»£ç†ä»¥ä¿æŠ¤ keyã€‚', true);
                    return 0;
                }

                // å¡«å……ä¸‹æ‹‰å¹¶æ˜¾ç¤º
                populateToiletSelect();
                loadAllToilets();
                updateStatus(`ä»é«˜å¾·æˆåŠŸæ£€ç´¢ ${NATIONAL_TOILET_DATA.length} ä¸ªå…¬å•`);
                return NATIONAL_TOILET_DATA.length;
            } catch (e) {
                updateStatus('ä»é«˜å¾·æ£€ç´¢å…¬å•å¤±è´¥: ' + (e.message || e), true);
                return 0;
            }
        }

        function populateToiletSelect() {
            const toiletSelect = document.getElementById('selectToilet');
            toiletSelect.innerHTML = '<option value="">è¯·é€‰æ‹©ç›®æ ‡å…¬å•</option>';
            NATIONAL_TOILET_DATA.forEach(toilet => {
                const option = document.createElement('option');
                option.value = toilet.id;
                option.textContent = `${toilet.name} (${toilet.city}) - çƒ­åº¦: ${toilet.popularity}`;
                toiletSelect.appendChild(option);
            });
        }

        // æ˜¾ç¤ºè°ƒè¯•é¢æ¿ï¼Œç”¨äºåˆ—å‡ºè¢«è·³è¿‡å’Œè¡¥å…¨å¤±è´¥çš„ POI
        function showDebugPanel(skippedList, lastGeocodedCount = 0) {
            const panel = document.getElementById('debugPanel');
            const summary = document.getElementById('debugSummary');
            const details = document.getElementById('debugDetails');
            if (!panel) return;
            panel.style.display = 'block';
            const total = skippedList ? skippedList.length : 0;
            summary.textContent = `è·³è¿‡æ— æ•ˆä½ç½®çš„ POI: ${total} æ¡ï¼ˆæœ€è¿‘ä¸€æ¬¡è¡¥å…¨æˆåŠŸ ${lastGeocodedCount} æ¡ï¼‰`;
            if (!skippedList || skippedList.length === 0) {
                details.textContent = 'æ— ';
                return;
            }
            let txt = '';
            skippedList.forEach((p, i) => {
                txt += `${i + 1}. ${p.name || p.id} | åœ°å€: ${p.address || ''} | åŸå¸‚: ${p.pname || p.cityname || p.adname || ''}\n`;
            });
            details.textContent = txt;
        }

        // ===== WMS æ¢æµ‹ç»“æœé¢æ¿æ”¯æŒ =====
        function updateWmsProbePanel() {
            const panel = document.getElementById('wmsProbePanel');
            const summary = document.getElementById('wmsProbeSummary');
            const details = document.getElementById('wmsProbeDetails');
            if (!panel || !summary || !details) return;
            panel.style.display = 'block';
            try {
                const s = [];
                if (wmsConfig && wmsConfig.version) s.push(`VERSION=${wmsConfig.version}`);
                if (wmsConfig && wmsConfig.crs) s.push(`${wmsConfig.crs}`);
                if (wmsConfig && wmsConfig.layer) s.push(`LAYERS=${wmsConfig.layer}`);
                summary.textContent = s.length ? `WMS å·²é€‰å®šï¼š ${s.join(' , ')}` : 'WMS æ¢æµ‹ï¼šæœªè¿è¡Œæˆ–æœªè¿”å›ç»“æœ';
            } catch (e) { summary.textContent = 'WMS æ¢æµ‹ï¼šè·å–ä¿¡æ¯å¤±è´¥'; }

            // æ˜¾ç¤ºæœ€è¿‘æ¢æµ‹æ—¥å¿—
            try {
                const log = (window._qgisWmsProbeLog || []).slice(-40).reverse();
                if (!log || log.length === 0) {
                    details.textContent = 'æ— æ¢æµ‹æ—¥å¿—';
                } else {
                    details.textContent = log.map((l, i) => `${i+1}. ${l.type} ${l.ok===false? 'FAILED':'OK'} ${l.status?('status='+l.status):''} ${l.note?l.note:''} ${l.error?l.error:''} ${l.url||''}`).join('\n');
                }
            } catch (e) { details.textContent = 'è¯»å–æ¢æµ‹æ—¥å¿—å¤±è´¥'; }
        }

        function setupWmsUiBindings() {
            try {
                const chk = document.getElementById('chkUseWmsProxy');
                const txt = document.getElementById('txtWmsProxyUrl');
                const btn = document.getElementById('btnCopyWmsLog');
                if (chk) {
                    chk.addEventListener('change', () => {
                        window._useWmsProxy = !!chk.checked;
                        updateStatus(`WMS ä»£ç†å·² ${window._useWmsProxy ? 'å¯ç”¨' : 'ç¦ç”¨'}`);
                    });
                }
                if (txt) {
                    txt.addEventListener('input', () => { window._wmsProxyUrl = txt.value.trim(); });
                }
                if (btn) {
                    btn.addEventListener('click', async () => {
                        const log = window._qgisWmsProbeLog || [];
                        try {
                            await navigator.clipboard.writeText(JSON.stringify(log, null, 2));
                            updateStatus('æ¢æµ‹æ—¥å¿—å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                        } catch (e) {
                            console.warn('å¤åˆ¶æ¢æµ‹æ—¥å¿—å¤±è´¥', e);
                            updateStatus('å¤åˆ¶æ¢æµ‹æ—¥å¿—å¤±è´¥ï¼š' + (e && e.message ? e.message : String(e)), true);
                        }
                    });
                }
            } catch (e) { console.debug('setupWmsUiBindings å¼‚å¸¸', e); }
        }

        // ============ å·¥å…·å‡½æ•° ============
        // æ–°å¢ï¼šæµ‹è¯•JS Keyä¸REST Keyï¼ˆå¿«é€Ÿè¯Šæ–­ï¼‰
        function testKeys() {
            updateStatus('æ­£åœ¨æµ‹è¯•Keyï¼šå…ˆæµ‹è¯• JS APIï¼ˆPlaceSearchï¼‰ï¼Œç„¶åæµ‹è¯• REST JSONP...');

            const results = [];

            // 1) æµ‹è¯• PlaceSearchï¼ˆJS APIï¼‰
            const jsTest = new Promise((resolve) => {
                if (typeof AMap !== 'undefined' && typeof AMap.PlaceSearch === 'function') {
                    const ps = new AMap.PlaceSearch({ pageSize: 1, pageIndex: 1, city: 'å…¨å›½' });
                    let to = setTimeout(() => {
                        resolve({ type: 'js', success: false, msg: 'PlaceSearch è¶…æ—¶' });
                    }, 6000);
                    ps.search('å•æ‰€', (status, result) => {
                        clearTimeout(to);
                        if (status === 'complete' && result && result.poiList && result.poiList.pois) {
                            resolve({ type: 'js', success: true, msg: `PlaceSearch æˆåŠŸï¼Œè¿”å› ${result.poiList.pois.length} æ¡` });
                        } else {
                            resolve({ type: 'js', success: false, msg: `PlaceSearch è¿”å›ï¼š${status}` });
                        }
                    });
                } else {
                    resolve({ type: 'js', success: false, msg: 'AMap.PlaceSearch ä¸å¯ç”¨' });
                }
            });

            // 2) æµ‹è¯• REST JSONPï¼ˆè‹¥å…³é”®è¯â€œå•æ‰€â€æ— ç»“æœåˆ™è‡ªåŠ¨å°è¯•â€œå…¬å•â€ï¼‰
            const restTest = new Promise((resolve) => {
                function doQuery(keyword, cbName, cbResolve) {
                    window[cbName] = function (data) {
                        try { delete window[cbName]; } catch (e) {}
                        if (script && document.body.contains(script)) document.body.removeChild(script);
                        cbResolve(data);
                    };
                    const script = document.createElement('script');
                    const url = `https://restapi.amap.com/v3/place/text?key=${CONFIG.AMAP_REST_KEY}&keywords=${encodeURIComponent(keyword)}&city=å…¨å›½&offset=1&page=1&output=json&extensions=all&callback=${cbName}`;
                    console.debug('[KeyTest] REST URL:', url);
                    script.src = url;
                    script.onerror = function () {
                        try { delete window[cbName]; } catch (e) {}
                        if (script && document.body.contains(script)) document.body.removeChild(script);
                        cbResolve({ error: 'JSONP åŠ è½½å¤±è´¥ï¼ˆå¯èƒ½ Key æ— æƒé™æˆ–è¢«é™åˆ¶ï¼‰' });
                    };
                    document.body.appendChild(script);
                    setTimeout(() => {
                        try { delete window[cbName]; } catch (e) {}
                        if (script && document.body.contains(script)) document.body.removeChild(script);
                        cbResolve({ error: 'JSONP è¯·æ±‚è¶…æ—¶' });
                    }, 7000);
                }

                // å…ˆå°è¯•â€œå•æ‰€â€
                doQuery('å•æ‰€', 'amap_test_cb_' + Date.now() + '_1', (res1) => {
                    if (!res1 || res1.error) {
                        return resolve({ type: 'rest', success: false, msg: res1 && res1.error ? res1.error : 'æœªçŸ¥é”™è¯¯' });
                    }
                    if (res1.pois && res1.pois.length > 0) {
                        return resolve({ type: 'rest', success: true, msg: `JSONP æˆåŠŸï¼ŒPOIs: ${res1.pois.length}` });
                    }
                    // è‹¥ 0 ç»“æœï¼Œå°è¯•â€œå…¬å•â€å…³é”®è¯
                    doQuery('å…¬å•', 'amap_test_cb_' + Date.now() + '_2', (res2) => {
                        if (!res2 || res2.error) {
                            return resolve({ type: 'rest', success: false, msg: res2 && res2.error ? res2.error : 'ç¬¬äºŒæ¬¡æŸ¥è¯¢æœªçŸ¥é”™è¯¯' });
                        }
                        if (res2.pois && res2.pois.length > 0) {
                            return resolve({ type: 'rest', success: true, msg: `JSONP æˆåŠŸï¼ˆä½¿ç”¨â€œå…¬å•â€ï¼‰ï¼ŒPOIs: ${res2.pois.length}` });
                        }
                        return resolve({ type: 'rest', success: false, msg: 'JSONP æˆåŠŸä½†æœªè¿”å› POIsï¼ˆä¸¤ä¸ªå…³é”®è¯å‡æœªå‘½ä¸­ï¼‰' });
                    });
                });
            });

            Promise.all([jsTest, restTest]).then(results => {
                let finalMsg = [];
                let isError = false;
                results.forEach(r => {
                    finalMsg.push(`${r.type.toUpperCase()}: ${r.success ? 'æˆåŠŸ' : 'å¤±è´¥'} - ${r.msg}`);
                    if (!r.success) isError = true;
                    console.log('[KeyTest]', r);
                });
                updateStatus(`Key æµ‹è¯•ç»“æœï¼š${finalMsg.join(' | ')}`, isError);
            });
        }

        // å°è¯•ä½¿ç”¨ AMap JS Geocoder è¡¥é½ç¼ºå¤±åæ ‡çš„ POIï¼ˆè¿”å›æˆåŠŸè¡¥å…¨çš„æ•°é‡ï¼‰
        // restGeocodeAddress ä½¿ç”¨ REST JSONP è¯·æ±‚åœ°ç†ç¼–ç ï¼ˆè¿”å› {lng,lat} æˆ– nullï¼‰
        function restGeocodeAddress(addr, timeout = 7000) {
            return new Promise((resolve) => {
                if (!addr) return resolve(null);
                const cbName = 'amap_geo_cb_' + Date.now() + '_' + Math.floor(Math.random() * 10000);
                const script = document.createElement('script');
                let resolved = false;
                const to = setTimeout(() => {
                    if (resolved) return;
                    resolved = true;
                    try { delete window[cbName]; } catch (e) {}
                    if (script && document.body.contains(script)) document.body.removeChild(script);
                    resolve(null);
                }, timeout);

                window[cbName] = function (data) {
                    if (resolved) return;
                    resolved = true;
                    clearTimeout(to);
                    try { delete window[cbName]; } catch (e) {}
                    if (script && document.body.contains(script)) document.body.removeChild(script);
                    try {
                        if (data && data.geocodes && data.geocodes[0] && data.geocodes[0].location) {
                            const loc = data.geocodes[0].location.split(',');
                            const lng = parseFloat(loc[0]);
                            const lat = parseFloat(loc[1]);
                            if (!Number.isNaN(lng) && !Number.isNaN(lat)) {
                                resolve({ lng, lat });
                                return;
                            }
                        }
                    } catch (e) { console.warn('è§£æ REST Geocode è¿”å›å¼‚å¸¸', e); }
                    resolve(null);
                };

                const url = `https://restapi.amap.com/v3/geocode/geo?key=${CONFIG.AMAP_REST_KEY}&address=${encodeURIComponent(addr)}&output=json&callback=${cbName}`;
                console.debug('[REST Geocode] URL:', url);
                script.src = url;
                script.onerror = function () {
                    try { delete window[cbName]; } catch (e) {}
                    if (script && document.body.contains(script)) document.body.removeChild(script);
                    resolve(null);
                };
                document.body.appendChild(script);
            });
        }

        async function geocodeMissingPOIs(pendingList, maxAttempts = 200, useRestFallback = false) {
            if (!pendingList || pendingList.length === 0) return 0;
            if (typeof AMap === 'undefined') {
                console.warn('AMap JS æœªåŠ è½½ï¼Œæ— æ³•è¿›è¡Œåœ°ç†ç¼–ç ï¼ˆä»…å¯ä½¿ç”¨ REST å›é€€ï¼‰');
                // è‹¥ AMap æœªåŠ è½½ä½†å…è®¸ REST å›é€€ï¼Œæˆ‘ä»¬å¯ä»¥å°è¯• REST æ–¹æ³•
                if (!useRestFallback) return 0;
            }

            // å°è¯•åŠ è½½ Geocoder æ’ä»¶ï¼ˆå¦‚æœå¯ç”¨ï¼‰
            if (typeof AMap !== 'undefined' && typeof AMap.Geocoder !== 'function' && AMap.plugin) {
                await new Promise((res) => {
                    let loaded = false;
                    try {
                        AMap.plugin(['AMap.Geocoder'], function () { loaded = true; res(); });
                    } catch (e) { console.warn('åŠ è½½ Geocoder æ’ä»¶å¤±è´¥', e); res(); }
                    setTimeout(() => { if (!loaded) res(); }, 3000);
                });
            }

            const hasJsGeocoder = (typeof AMap !== 'undefined' && typeof AMap.Geocoder === 'function');
            if (!hasJsGeocoder && !useRestFallback) {
                console.warn('æ—¢æ²¡æœ‰ JS Geocoderï¼Œä¹Ÿæœªå…è®¸ REST å›é€€ï¼Œæ— æ³•è¡¥å…¨åæ ‡');
                return 0;
            }

            const geocoder = hasJsGeocoder ? new AMap.Geocoder({ city: 'å…¨å›½' }) : null;
            let successCount = 0;

            const limit = Math.min(pendingList.length, maxAttempts);
            for (let i = 0; i < limit; i++) {
                const poi = pendingList[i];
                const addrParts = [poi.name, poi.address, poi.pname, poi.cityname, poi.adname].filter(Boolean).join(' ');
                const addr = addrParts || poi.name || '';
                let loc = null;

                try {
                    if (hasJsGeocoder) {
                        loc = await new Promise((resolve) => {
                            let called = false;
                            const to = setTimeout(() => { if (!called) { called = true; resolve(null); } }, 5000);
                            geocoder.getLocation(addr, (status, result) => {
                                if (called) return;
                                called = true; clearTimeout(to);
                                if (status === 'complete' && result && result.geocodes && result.geocodes[0] && result.geocodes[0].location) {
                                    resolve(result.geocodes[0].location);
                                } else {
                                    resolve(null);
                                }
                            });
                        });
                    }

                    // å¦‚æœ JS Geocoder æ²¡è¿”å›ä¸”å…è®¸ REST å›é€€ï¼Œåˆ™å°è¯• REST JSONP
                    if ((!loc || loc == null) && useRestFallback) {
                        const restLoc = await restGeocodeAddress(addr);
                        if (restLoc && restLoc.lng !== undefined && restLoc.lat !== undefined) {
                            loc = `${restLoc.lng},${restLoc.lat}`;
                        }
                    }

                    if (loc && loc.lng === undefined && typeof loc === 'string') {
                        // JS Geocoder è¿”å› 'lng,lat' å­—ç¬¦ä¸²
                        const parts = loc.split(',');
                        const lng = parseFloat(parts[0]);
                        const lat = parseFloat(parts[1]);
                        if (!Number.isNaN(lng) && !Number.isNaN(lat)) {
                            NATIONAL_TOILET_DATA.push({
                                id: poi.id || (`gaode_geo_${i}`),
                                name: poi.name || 'æœªçŸ¥å…¬å•',
                                lng: lng,
                                lat: lat,
                                city: poi.pname || poi.cityname || poi.adname || '',
                                type: 'general',
                                popularity: 50,
                                address: poi.address || ''
                            });
                            // æ ‡è®°ä¸ºå·²è¡¥å…¨
                            try { poi._geocoded = true; } catch (e) {}
                            successCount++;
                            continue;
                        }
                    }

                    // å¦‚æœ restGeocodeAddress è¿”å›å¯¹è±¡å½¢å¼
                    if (loc && typeof loc === 'object' && loc.lng !== undefined && loc.lat !== undefined) {
                        const lng = parseFloat(loc.lng);
                        const lat = parseFloat(loc.lat);
                        if (!Number.isNaN(lng) && !Number.isNaN(lat)) {
                            NATIONAL_TOILET_DATA.push({
                                id: poi.id || (`gaode_geo_${i}`),
                                name: poi.name || 'æœªçŸ¥å…¬å•',
                                lng, lat,
                                city: poi.pname || poi.cityname || poi.adname || '',
                                type: 'general',
                                popularity: 50,
                                address: poi.address || ''
                            });
                            // æ ‡è®°ä¸ºå·²è¡¥å…¨
                            try { poi._geocoded = true; } catch (e) {}
                            successCount++;
                            continue;
                        }
                    }

                    console.warn('Geocode æœªè¿”å›ä½ç½®ï¼ˆå·²å°è¯•ï¼‰ï¼š', poi && (poi.name || poi.id));
                } catch (e) {
                    console.warn('Geocode å¼‚å¸¸:', e);
                }

                // å°å»¶è¿Ÿï¼Œé¿å…é€Ÿç‡é™åˆ¶
                await new Promise(r => setTimeout(r, 200));
            }

            // æ›´æ–°å…¨å±€ skipped åˆ—è¡¨ï¼Œç§»é™¤å·²æˆåŠŸè¡¥å…¨çš„é¡¹
            try {
                if (window._skippedPOIs && Array.isArray(window._skippedPOIs)) {
                    window._skippedPOIs = window._skippedPOIs.filter(p => !p._geocoded);
                }
            } catch (e) {
                console.warn('æ›´æ–° _skippedPOIs æ—¶å‘ç”Ÿé”™è¯¯', e);
            }

            return successCount;
        }

        function calculateDistance(point1, point2) {
            // è¾“å…¥æ ¡éªŒï¼Œè‹¥ç‚¹ä¿¡æ¯ä¸å®Œæ•´åˆ™è¿”å› 0ï¼ˆé¿å…æŠ›å‡ºå¼‚å¸¸ï¼‰
            if (!point1 || !point2 || !Array.isArray(point1) || !Array.isArray(point2) || point1.length < 2 || point2.length < 2) return 0;
            const R = 6371000;
            const dLat = (point2[1] - point1[1]) * Math.PI / 180;
            const dLon = (point2[0] - point1[0]) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(point1[1] * Math.PI / 180) * Math.cos(point2[1] * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        function calculateTravelTime(distance, transport) {
            let speed = 5; // é»˜è®¤æ­¥è¡Œé€Ÿåº¦ km/h

            switch (transport) {
                case 'walking':
                    speed = 5; // 5 km/h
                    break;
                case 'driving':
                    speed = 40; // 40 km/h
                    break;
                case 'bicycling':
                    speed = 15; // 15 km/h
                    break;
                case 'transit':
                    speed = 20; // 20 km/h
                    break;
            }

            const hours = distance / 1000 / speed;
            return hours * 60; // è¿”å›åˆ†é’Ÿæ•°
        }

        function formatDistance(meters) {
            if (meters < 1000) {
                return `${Math.round(meters)}ç±³`;
            } else {
                return `${(meters / 1000).toFixed(1)}å…¬é‡Œ`;
            }
        }

        function formatTime(minutes) {
            if (minutes < 60) {
                return `${Math.round(minutes)}åˆ†é’Ÿ`;
            } else {
                const hours = Math.floor(minutes / 60);
                const mins = Math.round(minutes % 60);
                return mins > 0 ? `${hours}å°æ—¶${mins}åˆ†é’Ÿ` : `${hours}å°æ—¶`;
            }
        }

        function getTransportName(mode) {
            const names = {
                'walking': 'æ­¥è¡Œ',
                'driving': 'é©¾è½¦',
                'bicycling': 'éª‘è¡Œ',
                'transit': 'å…¬äº¤'
            };
            return names[mode] || mode;
        }

        function showToiletInfo(toilet, position) {
            const content = `
                <div style="padding: 12px; max-width: 250px;">
                    <div style="font-size: 16px; font-weight: bold; color: #2c3e50; margin-bottom: 8px;">
                        ${toilet.name}
                    </div>
                    <div style="color: #7f8c8d; margin-bottom: 4px;">
                        ğŸ“ ${toilet.city}
                    </div>
                    <div style="color: #555; margin-bottom: 4px;">
                        ğŸ”¢ ${toilet.type === 'accessible' ? 'æ— éšœç¢å•æ‰€' :
                    toilet.type === 'mother' ? 'æ¯å©´å®¤' : 'æ™®é€šå…¬å•'}
                    </div>
                    <div style="color: #e67e22; font-weight: 600;">
                        ğŸ”¥ çƒ­åº¦å€¼: ${toilet.popularity}/100
                    </div>
                </div>
            `;

            infoWindow.setContent(content);
            infoWindow.open(map, position);
        }

        function clearMarkers() {
            markers.forEach(marker => map.remove(marker));
            markers = [];
        }

        function updateStatistics() {
            const total = NATIONAL_TOILET_DATA.length;
            const general = NATIONAL_TOILET_DATA.filter(t => t.type === 'general').length;
            const accessible = NATIONAL_TOILET_DATA.filter(t => t.type === 'accessible').length;
            const mother = NATIONAL_TOILET_DATA.filter(t => t.type === 'mother').length;
            const displayed = markers.length;

            document.getElementById('totalToilets').textContent = total;
            document.getElementById('displayedToilets').textContent = displayed;
            document.getElementById('generalCount').textContent = general;
            document.getElementById('accessibleCount').textContent = accessible;
            document.getElementById('motherCount').textContent = mother;
        }

        function updateStatus(message, isError = false) {
            const statusDiv = document.getElementById('systemStatus');
            statusDiv.textContent = message;
            statusDiv.style.borderLeftColor = isError ? '#e74c3c' : '#3498db';
        }

        // ============ äº‹ä»¶ç»‘å®š ============
        function bindEvents() {
            // åœ°å›¾æ¨¡å¼
            document.getElementById('btnNormalMap').onclick = () => switchMapMode('normal');
            document.getElementById('btnSatellite').onclick = () => switchMapMode('satellite');
            document.getElementById('btnDarkHeatmap').onclick = () => switchMapMode('heatmap');

            // çƒ­åŠ›å›¾æ§åˆ¶ - æ–°å¢
            document.getElementById('btnHeatmapSmall').onclick = () => adjustHeatmapRadius(CONFIG.HEATMAP_OPTIONS.minRadius);
            document.getElementById('btnHeatmapMedium').onclick = () => adjustHeatmapRadius(CONFIG.HEATMAP_OPTIONS.radius);
            document.getElementById('btnHeatmapLarge').onclick = () => adjustHeatmapRadius(CONFIG.HEATMAP_OPTIONS.maxRadius);

            // ä½ç½®åŠŸèƒ½
            document.getElementById('btnSearchCity').onclick = searchCityToilets;
            document.getElementById('btnGetLocation').onclick = getGPSLocation;

            // QGIS WMS å›¾å±‚å¼€å…³ï¼ˆé˜²å¾¡æ€§ç»‘å®šï¼‰
            const _chkQgis = document.getElementById('chkQgisWms');
            if (_chkQgis) {
                _chkQgis.onchange = function () {
                    toggleQgisWms(!!this.checked);
                    updateStatus(this.checked ? 'QGIS WMS å›¾å±‚å·²å¯ç”¨' : 'QGIS WMS å›¾å±‚å·²ç¦ç”¨');
                };
            } else {
                console.debug('chkQgisWms æœªæ‰¾åˆ°ï¼Œè·³è¿‡ç»‘å®š');
            }

            // å…¬å•æ§åˆ¶
            document.getElementById('btnShowAll').onclick = () => fetchAllToiletsFromGaode(8);
            document.getElementById('btnTestKeys').onclick = testKeys;

            // æ‰‹åŠ¨è§¦å‘ï¼šä½¿ç”¨ REST Geocoder è¡¥å…¨ï¼ˆä»…åœ¨ä½ å‹¾é€‰å…è®¸æ—¶æ‰ä¼šä½¿ç”¨ï¼‰
            const _btnRunRest = document.getElementById('btnRunRestGeocode');
            const _chkRestAllow = document.getElementById('chkAllowRestGeocode');
            if (_btnRunRest) {
                _btnRunRest.onclick = async () => {
                    const skipped = window._skippedPOIs || [];
                    if (!skipped || skipped.length === 0) {
                        updateStatus('å½“å‰æ²¡æœ‰å¾…è¡¥å…¨çš„ POIï¼ˆæˆ–å·²å…¨éƒ¨è¡¥å…¨ï¼‰');
                        return;
                    }
                    if (!_chkRestAllow || !_chkRestAllow.checked) {
                        updateStatus('è¯·å…ˆå‹¾é€‰â€œå…è®¸ä½¿ç”¨ REST Geocoder è¡¥å…¨ï¼ˆä¼šä½¿ç”¨ REST Keyï¼‰â€é€‰é¡¹', true);
                        return;
                    }

                    updateStatus('æ‰‹åŠ¨è§¦å‘ï¼šä½¿ç”¨ REST Geocoder è¡¥å…¨ä¸­ï¼ˆè¯·ç¨å€™ï¼‰...');
                    try {
                        const count = await geocodeMissingPOIs(skipped, 500, true);
                        updateStatus(`REST è¡¥å…¨å®Œæˆï¼ŒæˆåŠŸè¡¥å…¨ ${count} æ¡ï¼ˆè¯·æŸ¥çœ‹è°ƒè¯•é¢æ¿æˆ–æ§åˆ¶å°ï¼‰`);
                        showDebugPanel(window._skippedPOIs || [], count);
                        // é‡æ–°å¡«å……å¹¶æ¸²æŸ“
                        populateToiletSelect();
                        loadAllToilets();
                    } catch (e) {
                        console.warn('REST è¡¥å…¨å‡ºé”™ï¼š', e);
                        updateStatus('REST è¡¥å…¨å¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°æ—¥å¿—', true);
                    }
                };
            } else {
                console.debug('btnRunRestGeocode æœªæ‰¾åˆ°ï¼ˆUI å¯èƒ½è¾ƒæ—§ï¼‰ï¼Œè·³è¿‡ç»‘å®š');
            }

            document.getElementById('btnClearAll').onclick = () => {
                // æ¸…ç†æ‰€æœ‰è‡ªå®šä¹‰æ˜¾ç¤ºï¼šæ ‡è®°ã€çƒ­åŠ›å›¾ã€å¯¼èˆªè½¨è¿¹ã€å¯¼èˆªäººç‰©ã€å¤–éƒ¨ WMS å›¾å±‚ï¼Œå¹¶æ¢å¤ä¸ºæ ‡å‡†åº•å›¾
                clearMarkers();

                // ç§»é™¤å¯¼èˆªçº¿
                if (navigationLine) {
                    try { map.remove(navigationLine); } catch (e) {}
                    navigationLine = null;
                }

                // ç§»é™¤å¯¼èˆªäººç‰©æ ‡è®°
                if (navCharacterMarker) {
                    try { map.remove(navCharacterMarker); } catch (e) {}
                    navCharacterMarker = null;
                }

                // åœæ­¢å¯¼èˆªåŠ¨ç”»å¹¶é‡ç½®çŠ¶æ€
                if (isNavigating) {
                    stopNavigation();
                }
                isNavigating = false;

                // æ¸…é™¤çƒ­åŠ›å›¾
                if (heatmapLayer) {
                    try { map.remove(heatmapLayer); } catch (e) {}
                    heatmapLayer = null;
                    try { document.getElementById('heatmapLegend').style.display = 'none'; } catch (e) {}
                }

                // ç§»é™¤ QGIS WMS å›¾å±‚ï¼ˆè‹¥å­˜åœ¨ï¼‰å¹¶ç¦ç”¨
                try { removeQgisWmsLayer(); } catch (e) {}
                isQgisWmsEnabled = false;

                // æ¸…ç† drivingServiceï¼ˆå¦‚æœæœ‰ï¼‰å¹¶éšè—çƒ­åŠ›å›¾å°çª—
                try { if (drivingService) { drivingService.clear(); drivingService = null; } } catch (e) { console.debug('æ¸…ç† drivingService å¤±è´¥', e); }
                try { const hv = document.getElementById('heatmapValue'); if (hv) hv.style.display = 'none'; } catch (e) {}

                // æ›´æ–°çƒ­åŠ›å›¾ä¿¡æ¯æ˜¾ç¤ºä¸ºæœªå¯ç”¨
                try { const el = document.getElementById('heatmapInfo'); if (el) el.textContent = 'çƒ­åŠ›å›¾ï¼šæœªå¯ç”¨'; } catch(e){}

                // å¼ºåˆ¶åˆ‡æ¢å›æ ‡å‡†åœ°å›¾åº•å›¾ï¼ˆç§»é™¤å«æ˜Ÿ/è‡ªå®šä¹‰ç“¦ç‰‡ï¼‰
                try { switchMapMode('normal'); } catch (e) { console.debug('åˆ‡æ¢æ ‡å‡†åœ°å›¾å¤±è´¥', e); }
                // éšè—å¯¼èˆª UI
                try { document.getElementById('navInfo').style.display = 'none'; } catch (e) {}
                try { document.getElementById('navProgress').style.display = 'none'; } catch (e) {}
                try { document.getElementById('btnPauseNavigation').style.display = 'none'; } catch (e) {}

                updateStatus('å·²æ¸…ç©ºæ˜¾ç¤ºå¹¶æ¢å¤æ ‡å‡†åœ°å›¾');
                updateStatistics();
            };

            // å¯¼èˆªåŠŸèƒ½
            document.getElementById('btnStartNavigation').onclick = startNavigation;
            document.getElementById('btnPauseNavigation').onclick = togglePauseNavigation;
            document.getElementById('btnStopNav').onclick = stopNavigation;

            // åˆå§‹åŒ–å…¬å•ä¸‹æ‹‰ä¸ºç©ºï¼ˆé€šè¿‡é«˜å¾·å¡«å……ï¼‰
            const toiletSelect = document.getElementById('selectToilet');
            toiletSelect.innerHTML = '<option value="">è¯·é€‰æ‹©ç›®æ ‡å…¬å•</option>';
        }

        // æ–°å¢ï¼šåœæ­¢å¯¼èˆª
        function stopNavigation() {
            isNavigating = false;
            isPaused = false;
            if (navAnimationFrame) {
                cancelAnimationFrame(navAnimationFrame);
            }
            if (navCharacterMarker) {
                map.remove(navCharacterMarker);
                navCharacterMarker = null;
            }
            if (navigationLine) {
                map.remove(navigationLine);
                navigationLine = null;
            }
            // æ¸…ç† drivingServiceï¼ˆå¦‚æœ Driving æ’ä»¶æ·»åŠ äº†é¢å¤–è¦†ç›–ï¼‰
            try { if (drivingService) { drivingService.clear(); drivingService = null; } } catch (e) { console.debug('æ¸…ç† drivingService å¤±è´¥', e); }

            document.getElementById('navInfo').style.display = 'none';
            document.getElementById('navProgress').style.display = 'none';
            document.getElementById('btnPauseNavigation').style.display = 'none';
            navPath = [];
            navCurrentIndex = 0;
            // åŒæ—¶éšè—å³ä¾§çƒ­åŠ›å›¾å°çª—ä¸­çš„å€¼ï¼ˆè‹¥ä½ æƒ³ä¿ç•™åˆ™å¯å–æ¶ˆï¼‰
            try { const hv = document.getElementById('heatmapValue'); if (hv) hv.style.display = 'none'; } catch (e) {}
            updateStatus('å¯¼èˆªå·²ç»“æŸ');
        }

        // ============ ä¿®å¤ï¼šç³»ç»Ÿåˆå§‹åŒ–ï¼ˆç¡®ä¿å®¹å™¨æ¸²æŸ“ï¼‰ ============
        window.onload = function () {
            const mapContainer = document.getElementById('mapContainer');
            // æ ¡éªŒå®¹å™¨å°ºå¯¸æ˜¯å¦æ­£å¸¸ï¼Œå¼ºåˆ¶ä¿®å¤
            if (mapContainer.offsetHeight === 0 || mapContainer.offsetWidth === 0) {
                mapContainer.style.width = '100%';
                mapContainer.style.height = 'calc(100vh - 60px)';
                updateStatus('å®¹å™¨å°ºå¯¸å¼‚å¸¸ï¼Œå·²å¼ºåˆ¶ä¿®å¤');
            }

            if (typeof AMap !== 'undefined') {
                initMap();
                bindEvents();
                // åˆå§‹åŒ–åè§¦å‘ä¸€æ¬¡é‡ç»˜ï¼Œç¡®ä¿åœ°å›¾æ¸²æŸ“å®Œæ•´
                setTimeout(() => map.resize(), 500);
                updateStatus('å…¨å›½å…¬å•ç³»ç»Ÿå·²å°±ç»ªï¼ˆå¢å¼ºçƒ­åŠ›å›¾ç‰ˆï¼‰');
            } else {
                updateStatus('é«˜å¾·åœ°å›¾APIæœªåŠ è½½ï¼Œå°è¯•åŠ¨æ€åŠ è½½JS API...', true);
                loadAMapScript((err) => {
                    if (err) {
                        updateStatus('é«˜å¾·åœ°å›¾JS APIåŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ JS Key ä¸å®‰å…¨å¯†é’¥ï¼ˆAMAP_JS_KEY / AMAP_JS_SECURITYï¼‰æˆ–ç½‘ç»œ', true);
                        return;
                    }
                    initMap();
                    bindEvents();
                    setTimeout(() => map.resize(), 500);
                    updateStatus('å…¨å›½å…¬å•ç³»ç»Ÿå·²å°±ç»ªï¼ˆå¢å¼ºçƒ­åŠ›å›¾ç‰ˆï¼‰');
                });
            }
        };
    </script>
</body>

</html>